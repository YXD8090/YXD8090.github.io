<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/09/JS%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/02/09/JS%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>第一天</p><p>面向过程与面向对象</p><p>面向过程<br>面向过程就是分析出解决问题的步骤，然后按照步骤一步一步处理，使用的时候依次调用即可。</p><p>面向对象<br>面向对象就是将事件分为一个一个对象，然后由各个对象分工合作处理事件。</p><p>对比<br>面向过程 面向对象<br>面向过程比面向对象性能更高，适合与硬件练习紧密的东西 易维护，易复用，易扩展，由于面向对象由封装、继承、多态性的特性，可以设计除低耦合的系统，通常在多人合作中使用。<br>不易维护，不易复用，不易扩展 性能比面向过程低</p><p>对象与类</p><p>对象<br>对象是由无序的多个属性和方法组成的集合。</p><p>创建对象<br>字面量创建<br>var obj = {}</p><p>构造函数创建<br>function Student (name,age) {<br>    this.name = name;<br>    this.age = age;<br>}<br>var obg = new Student(‘小红’,12)</p><p>类<br>在es6中新增了类的概念，可以使用class关键字申明一个类，然后用类创建多个实例化对象。<br>类是抽象了对象的公共部分，泛指一大类，而对象特指某一个，通过实例化来创建对象。</p><p>类的创建和添加属性、方法<br>//类名后面直接跟{}大括号，不需要（）小括号<br>class Student {<br>    //将共有的属性放到constructor里面<br>    constructor(name,age,height){<br>        this.name = name;<br>        this.age = age;<br>        this.height = height;<br>    }<br>    //注意方法和方法之间不需要加，逗号<br>   //注意在类中帮我们省略了function声明函数，直接写（）{}就可以<br>   sey(){<br>       console.log(‘hello’)<br>   }<br>}<br>var xm = new Student(‘小明’,12,150);<br>xm.sey();</p><p>注意：1.通过class关键字创建的类，类名首字母大写。<br>2.类里面有一个constructor函数，可以接收传过来的参数，同时返回实例对象<br>3.constructor函数只要new生成实例对象就会自动调用，就算我们不写也会自动生成这个函数。<br>4.多个函数方法之间不需要逗号分割<br>5.生成实例时必须要加new<br>6.语法规范，创建类 类名后不需要小括号，方法构造函数不需要加function。</p><p>类的继承</p><p>语法<br>class Father {<br>    constructor(x,y){<br>        this.x = x;<br>        this.y = y<br>    }<br>}<br>class Son extends Father{<br>    constructor(x,y){<br>        super(x,y)<br>    }<br>}</p><p>注意：<br>1.继承中，子类要想使用this必须先调用super()之后才能使用this属性<br>2.如果子类创建的实例化对象需要调用方法或者属性，先看子类里有没有，有则调用子类的方法或者属性，没有则到父类中查找。<br>3.注意this指向问题<br>4.在ES6中类没有变量提升，所以必须先定义类，才能通过实例化对象。</p><p>面向对象版tab栏切换<br>E:\html\html\JS高级\day01\lesson001(1)\009-tab栏选项卡案例\index.html</p><p>第二天</p><p>一、构造函数和原型</p><p>1.对象的三种创建方式</p><p>（1）字面量创建<br>var obj = {}</p><p>（2）new关键字<br>var obj = new Object()</p><p>（3）构造函数<br>function Obj (name,age){<br>    this.name =name;<br>    this.age = age;<br>}<br>var obj = new Obj(‘小明’,12)</p><p>2.构造函数的成员</p><p>（1）实例成员<br>实例成员就是构造函数通过this添加的属性或者方法。实例成员只能通过实例化的对象进行访问。<br>//构造函数中的this指向的是创建的实例对象，函数和对象都属于复杂数据类型<br>//复杂数据类型变量或者函数名保存的是复杂数据类型的地址值<br>//因为new关键字创建了新的内存空间，this将参数传给了实例对象所以构造函数无法获取<br>//实例对象中的属性和方法，也就无法获取实例成员<br>function Obj (name,age){<br>    this.name = name;<br>    this.age = age;<br>    this.sey = function(){<br>        console.log(‘hello’)<br>    }<br>}<br>var xm = new Obj(‘小明’,12);<br>console.log(xm.name)//结果为  小明<br>console.log(Obj.name)//结果为 undefined</p><p>（2）静态成员<br>静态成员是对构造函数本身进行添加的属性或者方法。静态成员只能通过构造函数进行访问，构造函数创建的实例对象无法访问。<br>//因为构造函数创建的实例对象和构造函数本身不是一个内存空间<br>//所以给构造函数单独添加的属性和方法跟和实例对象不是在一个内存空间<br>//实例对象就无法获取静态成员。<br>function Obj (name,age){<br>    this.name = name;<br>    this.age = age;<br>    this.sey = function(){<br>        console.log(‘hello’)<br>    }<br>}<br>Obj.sex = ‘男’;<br>var xm = new Obj(‘小明’,12);<br>console.log(xm.sex)//结果为  undefined<br>console.log(Obj.sex)//结果为 男</p><p>3.构造函数的问题<br>构造函数在创建实例对象的时候，会有这样一个问题。因为每次调用构造函数new关键字就会创建一个新的内存空间，而对象中的方法也是复杂数据类型也需要单独的内存空间存放。当创建多个实例对象的时候就会出现资源浪费的情况。</p><p>4.构造函数原型prototype<br>js规定每个构造函数都有prototype原型对象，原型对象是所有构造函数创建出的实例对象所共享的。<br>可以将那些不变或者相同的方法直接定义在prototype上，这样所有实例对象都能够使用这些方法。</p><p>5.对象原型<br>所有对象都有一个属性__proto__指向的是构造函数的prototype原型对象。实例对象之所以能够使用prototype里的方法和属性就是因为__proto__的存在。</p><p>6.constructor构造函数<br>所有对象原型__proto__和构造函数的原型对象prototype都有一个属性就是constructor属性，constructor指向的是构造函数本身，主要用于记录该实例对象和原型对象是哪个构造函数的。</p><p>一般情况下，对象的方法都在构造函数的原型对象中设置，如果有多个方法则可以给原型对象进行赋值。但是这样会覆盖掉constructor属性，所以我们需要手动添加constructor属性重新手动设置指向构造函数本身。</p><p>7.原型链<br>因为每个对象都有proto属性，指向构造函数的原型对象，原型对象也有proto属性，这样一层一层的往上叫做原型链。</p><p>8.原型对象和构造函数实例对象的关系<br>（1）构造函数的prototype属性指向了原型对象。<br>（2）实例对象的proto对象原型属性指向了原型对象。<br>（3）原型对象的constructor属性指向了构造函数，实例对象的原型proto里面的constructor也指向了构造函数。</p><p>9.原型链和成员的查找机制<br>当访问一个对象的属性或者方法时，先从自身查找是否有该属性或者方法。如果有则访问自身的，如果没有则查找它的原型对象。有则访问没有则继续向上。如果都没有则返回null。</p><p>10.原型对象中的this指向问题<br>构造函数中的this和原型对象中的this都指向构造出来的原型对象。</p><p>11.通过原型为数组扩展内置方法<br>Array.prototype.sum = function (){<br>    var sum = 0;<br>    for (var i = 0 ; i &lt; this.length ; i++){<br>        sum += this[i];<br>    }<br>    return sum;<br>}</p><p>二、继承</p><p>1.call()<br>call()时调用函数时可以修改this指向，小括号里的第一个参数是this的指向，后面的参数是对应函数形参的实参。使用逗号分割。<br>function fn (x,y){<br>    console.log(this);<br>    console.log(x + y)<br>}<br>fn.call([],1,2);//调用函数并且修改this指向，将this指向[]空数组。</p><p>2.子构造函数继承父构造函数<br>使用call方法调用父构造函数并修改this指向。<br>function Father (name,age){<br>    this.name = name;<br>    this.age = age;<br>}<br>function Son (name,age,height) {<br>    //使用call方法调用父构造函数并将this指向Son构建的实例对像<br>    Father.call(this,name,age);<br>    this.height = height;<br>}</p><p>3.利用原型对象继承方法<br>利用原型对象的共享方法来继承父构造函数的方法<br>function Father (name,age){<br>    this.name = name;<br>    this.age = age;<br>};<br>Father.prototype.sey = function(){<br>    console.log(‘hello’)<br>}<br>function Son (name,age,height) {<br>    //使用call方法调用父构造函数并将this指向Son构建的实例对像<br>    Father.call(this,name,age);<br>    this.height = height;<br>}<br>//将父构造函数的原型对象赋值给子构造函数的原型对象<br>//这样子构造函数创建的实例对象也能够使用父构造函数的方法<br>Son.prototype = new Father();<br>//但是这样赋值会出现原型对象的constructor属性丢失，需要手动添加指向子构造函数<br>Son.prototype.constructor = Son;</p><p>三、ES5新增方法</p><p>1.数组方法</p><p>forEach遍历数组<br>var arr = [1,2,3,4]<br>arr.forEach(function(value,index,arr){<br>    //参数1是遍历数组的每个数组元素相当于arr[i]<br>    //参数2是元素的索引值<br>    //参数3是数组本身<br>})</p><p>filter过滤数组<br>var arr = [1,2,3,4]<br>var newArr = arr.filter(function(value,index,arr){<br>    //筛选符合条件的元素，返回的是符合条件的元素组成的数组<br>    retur value &lt; 3;<br>})</p><p>some判断数组中是否有符合条件的元素<br>var arr = [1,2,3,4]<br>arr.some(function(value,index,arr){<br>    //判断数组中是否有符合条件的元素，返回的是布尔值<br>    return value &gt;= 4<br>})</p><p>every判断数组中元素是否都符合条件<br>var arr = [1,2,3,4]<br>arr.every(function(value,index,arr){<br>    //判断数组中的元素是否都符合条件，返回的是布尔值<br>    return value &gt; 10;<br>})</p><p>注意：</p><ol><li>forEach 和 filter 都会遍历完整个数组，return不会终止此循环。</li><li>some 和 every 不一定会遍历完数组，使用 some 当有元素符合则终止循环，使用 every 当有元素不符合则终止循环。</li></ol><p>2.字符串方法</p><p>trim去除字符串两端的空格<br>var str = ‘     abc     ‘<br>//去除字符串两端的空格<br>var str1 = str.trim()</p><p>3.对象方法</p><p>Object.keys(对象)获取对象的属性名<br>var obj = {<br>    name : ‘小明’,<br>    age : 12,<br>    height : 140<br>}<br>//获取对象里所有的属性名，返回值是一个数组。<br>var res = Object.keys(obj) </p><p>Object.definePropety 修改或新增对象的属性名<br>var obj = {<br>    name : ‘小明’,<br>    age : 12,<br>    height : 140<br>}<br>Object.definePropety(对象,修改或者新增属性名,{<br>    value:修改或者新增属性的值<br>    //属性的特性<br>    writable:true/false,//是否能够修改这个属性值，true是，false不可以<br>   enumerable:true/false,//是否允许遍历这个属性，true是，false不可以<br>   configurable:true/false,//是否允许删除或者修改特性，true是，false不可以<br>})</p><p>第三天</p><p>一、改变函数的this指向</p><p>1.call方法<br>使用call()方法调用函数，可以修改函数this的指向<br>function fn (str){<br>    console.log(this)<br>    console.log(str)<br>}<br>//第一个参数是函数中this的指向<br>fn.call({},123)</p><p>2.apply方法<br>使用apply()方法调用函数也可以改变函数this指向<br>function fn (str,num){<br>    console.log(this)<br>    console.log(str,num)<br>}<br>//第一个参数是函数中this的指向<br>fn.apply({},[‘小明 ‘,123]])</p><p>注意：与call方法不同的是apply方法第一个参数后面的实参是以数组的形式书写的，但是传递参数的方式还是一一对应的。</p><p>3.bind方法<br>使用bind方式不会调用函数，但是能改变函数this的指向返回的是一个新的函数。<br>function fn (str,num){<br>    console.log(this)<br>    console.log(str,num)<br>}<br>//第一个参数是函数中this的指向<br>var fun = fn.bind({},[‘小明 ‘,123]])<br>fun()//注意bind可以预设参数，预设之后可以直接调用函数不用传参，就算传参也不能修改</p><p>4.call、apply、bind相同点和不同点<br>相同点：都可以修改this指向</p><p>不同点：<br>call 和 apply 都会调用函数，bind不会调用函数会生成新的函数，并且可以预设参数<br>call 和 bind 传递参数都是以逗号隔开，而apply是数组的形式</p><p>应用场景：<br>call 常用于构造函数的继承<br>apply常与数组搭配使用<br>bind 常用于回调函数不调用函数改变this指向</p><p>二、严格模式</p><p>1.开启严格模式</p><p>为脚本开启严格模式</p><script>//当前script标签开启严格模式"use strict"</script><p>为函数开启严格模式<br>function fn (){<br>    //为函数开启严格模式<br>    “use strict”<br>}</p><p>2.严格模式中的变化<br>（1）严格模式中变量未声明不能使用，也不不能直接赋值<br>（2）严格模式中this默认是undefined<br>（3）严格模式中构造函数调用必须加new关键字<br>（4）严格模式中函数的参数不能重名</p><p>三、高阶函数</p><p>高阶函数对其他函数进行操作的函数，它接收的参数为函数或者返回的值是函数。这种函数称之为高阶函数。<br>例：<br>function fn (fun){<br>    fun()<br>}<br>function fun (){<br>    console.log(123)<br>}<br>//传入的参数是函数</p><p>function fn (){<br>   return function (){<br>    console.log(123)<br>    }<br>}<br>//返回的值是函数</p><p>四、闭包</p><p>闭包的定义：闭包是指内部函数访问外部函数声明的变量的结构称为闭包。<br>例：<br>function fu (){<br>    var num = 10;<br>    function (){<br>        console.log(num + 10)<br>    }<br>}</p><p>闭包的作用<br>1.闭包可以延申了变量的使用范围<br>2.实现了数据的封装<br>3.实现了数据的缓存（函数的柯里化）</p><p>闭包的缺点<br>1.闭包会是函数的变量都保存在内存中加大内存消耗（空间换时间）<br>2.容器容易引发内存泄漏（没有及时清理）</p><p>注意：闭包之所以能够保存函数变量，是因为在js的GC（垃圾清理机制）中会定期检查找出清理垃圾，当变量不再被引用时会进行清除释放内存。</p><p>闭包的应用<br>通过闭包获取for循环中的i变量<br>for (var i = 0; i &lt;10; i++){<br>    !(function(i){<br>    div.onclick = function(i){<br>        console.log(i)<br>    }<br>    })(i)<br>}<br>//通过立即执行函数创造一个小闭包，在将for循环中的i通过实参传递给内部的事件处理函数</p><p>五、递归</p><p>递归函数的定义：如果一个函数在内部调用自身，那么这个函数就是递归函数。<br>注意：递归函数的作用和for循环效果一样，由于递归容易引发‘栈溢出’错误，所以必须要加退出条件return。</p><p>递归函数的应用<br>获取树状数据<br>var data = [{ id: 1,<br>            name: ‘家电’,<br>            goods: [{ id: 11,<br>                    gname: ‘冰箱’,<br>                    goods: [{ id: 111,<br>                            gname: ‘海尔’ },<br>                            { id: 112,<br>                             gname: ‘美的’ }, ] },<br>            { id: 12,<br>             gname: ‘洗衣机’ }] },<br>           { id: 2,<br>            name: ‘服饰’ }];<br>function deepData (arr,id){<br>    //申明变量保存查询结果<br>    var res = null;<br>    //遍历数组<br>    arr.forEach(function(itme){<br>        //判断是否符合条件<br>    if (itme.id == id){<br>        //符合则保存结果<br>        res = itme;<br>        //因为forEach不会中断循环所以要判断是否已经找到数据，并判断这个数据是否有goods属性<br>    } else if (res == null &amp;&amp; itme.goods){<br>        //没有找到数据则再调用函数进入深层寻找<br>       res = deepData(itme,id);<br>    }<br>    //输出结果<br>    return res<br>    })<br>}<br>deepData(data,11)</p><p>第四天</p><p>正则表达式<br>正则表达式是用于匹配字符串组合的模式，再js中正则表达式也是对象。</p><p>正则表达式的特点<br>灵活性、逻辑性和功能性非常强，可以迅速地用极简单的方式达到字符串的复杂控制。</p><p>正则表达式的组成<br>正则表达式由简单字符构成或者字符与特殊字符的组合。<br>/abc/</p><p>边界符 ^  $<br>/^abc/<br>//以abc字符串开头<br>/abc$/<br>//以abc字符结尾<br>/^abc$/<br>//精准匹配，必须是abc，精确匹配字符数量和类型都需要符合</p><p>字符集[]<br>/[abcd]/<br>//表示字符中出现中括号中的任意一个字符即可，[]只能匹配一个字符<br>/^[abcd]/<br>//表示字符以中括号中的任意一个字符开头<br>/[abc]$/<br>//表示字符以中括号中的任意一个字符结尾<br>/^[abc]$/<br>//表示字符只能是中括号中任意一个字符<br>/^[0-9]$/<br>//表示0-9中任意个数字<br>/^[^abc]$/<br>//表示除了abc以外任何一个字符   [^] 取反字符，除了中括号里面的任意一个字符</p><p>量词符<br>/^abc*$/<br>//表示ab后面的c可以出现0次或者更多次 * ==（&gt;=0）<br>/^abc+$/<br>//表示ab后面的c可以出现1次或者更多次  + ==（&gt;=1）<br>/^abc?$/<br>//表示ab后面的c可以出现1次或者0次  ? ==（0 || 1）<br>/^abc{3}$/<br>//表示ab后面的c必须出现3次    {3} == 3<br>/^abc{3,}$/<br>//表示ab后面的可以出现3次或以上    {3,} ==（&gt;=3）<br>/^abc{3,4})$/<br>//表示ab后面的可以出现3次到4次    {3,4} ==（&gt;=3 &amp;&amp; &lt;= 4）</p><p>其他特殊字符<br>/^(abc|qwe)$/<br>//表示abc或者qwe    | == 或<br>/./<br>//  . 点表示除了换行符以外的所有字符<br>/./<br>// . 表示点</p><p>括号总结<br>1.小括号表示整体，优先执行<br>2.中括号表示字符集和，匹配中括号中的任意一个字符<br>3.大括号表示两次符，里面表示重复几次</p><p>预定义类<br>\d   ：匹配0-9之间任意一个数字，相当于 [0-9]<br>\D  ：匹配除了数字以外的所有字符串，相当于[^0-9]<br>\w  ：匹配所有字母，数字和下划线，相当于[a-zA-Z0-9_]<br>\W ：匹配除了字母，数字和下划线以外的任意一个字符，相当于[^a-zA-Z0-9_]<br>\s  ：匹配空格（空格，换行符，制表符等），相当于[\t\r\n\v\f]<br>\S ：匹配非空格，相当于[^\t\r\n\v\f]</p><p>检查是否符合正则test<br>test()方法用来判断字符串是否符合正则表达式，符合返回true，否则返回false<br>var str = /^abc$/;<br>str.test(‘abc’)//true</p><p>正则替换replace<br>replace()方法用来替换字符串中的字符。<br>let str = ‘abcdaefag’;<br>str.replace(‘a’,’你好’)//将str中第一个‘a’替换为‘你好’</p><p>replace()方法中第一个参数可以是正则表达式<br>let str = ‘abcdaefagA’;<br>str.replace(/a/,’你好’)//将str中第一个‘a’替换为‘你好’<br>str.replace(/a/g,’你好’)//将str中所有‘a’替换为‘你好’<br>str.replace(/a/i,’你好’)//将str中第一个‘a’替换为‘你好’，不区分大小写<br>str.replace(/a/gi,’你好’)//将str中所有‘a’替换为‘你好’，不区分大小写</p><p>注意：筛选字符串中需要替换的字符时不能使用精确匹配</p><p>正则匹配exec返回的是一个数组<br>let str = ‘asdfasdfdfadsfadsfads’;<br>let reg = /a/;<br>reg.exec(str);//匹配str字符串中的a，返回的是一个数组，每次只能匹配一个</p><p>第五天</p><p>Es6概念<br>6指的是从ES2015开始之后的所有版本，统称为ES6</p><p>ES6新增语法</p><p>块级作用域<br>在ES6中除了对象的大括号以外的所有{}内都是块级作用域。</p><p>新增变量声明★★★</p><p>let<br>let num = 10;</p><p>注意：使用let关键字声明的变量才具有块级作用域，使用var关键字是没有的<br>特性：<br>（1）let关键字申明的变量只在当前块级作用域和子块级作用域内有效<br>（2）let关键字声明的变量不存在变量提升，必须先声明再使用。<br>（3）存在‘暂存死区’，在全局作用域中声明一个变量，之后在块级作用域内声明同一个变量，此时在块级作用域中声明变量之前无法访问该变量。<br>（4）let关键字声明的变量不会自动挂载到window上。<br>（5）let关键字声明的变量同一作用域下变量名不能重复。</p><p>作用：<br>（1）防止循环变量变成全局变量，通过var声明的循环变量在循环体外也是可以访问的。<br>（2）和闭包一样可以保存循环的变量值。</p><p>const<br>const num = 10;</p><p>特性：<br>（1）const关键字声明变量必须使用用初始化，声明同时赋值。<br>（2）const关键字声明的变量具有不可变性，值为基础数据类型时不可修改，值为复杂数据类型时，可以修改复杂数据类型的内容，但是不能再次赋值为新的复杂数据类型。<br>（3）const关键字申明的变量只在当前块级作用域和子块级作用域内有效<br>（4）const关键字声明的变量不存在变量提升，必须先声明再使用。<br>（5）存在‘暂存死区’，在全局作用域中声明一个变量，之后在块级作用域内声明同一个变量，此时在块级作用域中声明变量之前无法访问该变量。<br>（6）const关键字声明的变量不会自动挂载到window上。<br>（7）const关键字声明的变量同一作用域下变量名不能重复。</p><p>解构赋值★★★</p><p>数组解构<br>let arr = [1,2,3,4,5];<br>let [a,b,c,d,e] = arr;<br>// a = 1 , b = 2, c = 3, d = 4, e = 5</p><p>数组结构会将数组里的元素按照顺序赋值给左边中括号中的变量。当变量多过元素后面的变量的值为undefined。如果不想获取某个元素，则使用逗号跳过该元素。<br>let arr = [1,2,3,4,5];<br>let [a,,b,c,d,e] = arr;<br>// a = 1 , b = 3, c = 4, d = 5, e = undefined</p><p>对象属性的解构<br>let obj = {<br>    a:1,<br>    b:2,<br>    c:3<br>}<br>let {a,b,c} = obj;<br>//a = 1, b =2 , c = 3;</p><p>对象结构，左边的大括号中需要写入对应属性名的变量名才能获取对应的属性值，如果没有对应变量名的属性则值为undefined。如果想让变量命名和属性名不一致，则需要以此格式书写    属性名：变量名,也可以使用此格式获取对象中的复杂数据类型。<br>let obj = {<br>    a:1,<br>    b:2,<br>    c:3<br>}<br>let {a:num,b,c} = obj;<br>//num = 1, b =2 , c = 3;</p><p>箭头函数★★★<br>ES6中新增定义函数的方式<br>() =&gt; {} //小括号表示参数，大括号表示函数体</p><p>特性：<br>（1）当函数只有一行代码并且就是返回值时可以省略大括号<br>（2）当函数只接收一个参数时可以省略下括号<br>（3）箭头函数中没有this指向，箭头函数中的this指向的是函数所在作用域的this指向。（重点）<br>（4）箭头函数不能使用 arguments 这个内置对象。</p><p>剩余参数<br>当函数需要接收多个变量时，可以通过 …变量名接收剩余参数或者全部参数，变量为一个数组<br>function fn (a,b,…c){<br>    console.log(a,b,c)// 1 2 [3,4,5,6,7]<br>}<br>fn (1,2,3,4,5,6,7)</p><p>剩余参数通常和结构配合使用<br>let arr = [1,2,3,4,5];<br>let [a,b,…c] = arr;<br>//a = 1 , b = 2 , c = [3,4,5]</p><p>ES6的内置对象扩展</p><p>Array（数组）的扩展方法★★★</p><p>扩展运算符<br>扩展运算符可以将数组和对象转化为用逗号分割的参数序列。<br>let arr = [1,2,3,4];<br>…arr // 1,2,3</p><p>扩展运算符可以用作数组的合并<br>let arr1 = [1,2,3];<br>let arr2 = [4,5,6];<br>let arr3 = […arr1,…arr2]</p><p>可以将伪数组或者类数组转换成正真的数组</p><p>Array.from() 方法<br>可以将伪数组或者类数组转换成正真的数组，该方法还可以接收第二个参数用来遍历修改数组<br>let arrayLike = { ‘0’: ‘a’,<br>                ‘1’: ‘b’,<br>                ‘2’: ‘c’,<br>                length: 3 };<br>let arr2 = Array.from(arrayLike,function(itme,index,arr){<br>    itme += 1<br>}); // [‘a1’, ‘b1’, ‘c1’]</p><p>find() 方法<br>find方法时找出数组中第一个符合条件的元素，有则返回该元素，没有则返回undefined。<br>let arr = [1,2,3,4];<br>arr.find(itme =&gt; itme &gt; 2) //返回 3</p><p>findIdex() 方法<br>findIdex() 方法是找出数组中第一个符合条件的元素，返回的是该元素的索引号，没有则返回-1<br>let arr = [1,2,3,4];<br>arr.findIdex(itme =&gt; itme &gt; 2) //返回 2</p><p>includes() 方法<br>includes() 方法是查询该数组是否包含给定的值。返回的是布尔值<br>let arr = [1,2,3,4];<br>arr.includes(2) //返回 true</p><p>String 的扩展方法</p><p>模板字符串★★★<br>ES6中新增的创建字符串的方式，使用反引号定义<br>let str = <code>abcd</code></p><p>在模板字符串中可以添加变量和任何表达式<br>let num = 10;<br>let str = <code>abdc$&#123;num&#125;asdfa</code><br>//大括号中可以是变量或者任何表达式</p><p>在模板字符串中可以换行<br>let str = <code>ab cd</code></p><p>starsWith() 和  endsWith() 方法<br>startsWith()：表示参数字符串是否以小括号内字符串开头，返回布尔值<br>endsWith()：表示参数字符串是否以小括号内字符串结尾，返回布尔值</p><p>repeat() 方法<br>repeat() 方法表示将源字符串重复几次。<br>let str = <code>abcd</code>;<br>str.repeat(10)//该字符串重复10次</p><p>Set数据结构★★<br>ES6提供了新的Set数据结构，它类似数组，但是成员的值都具有唯一性，不会出现重复的情况。</p><p>创建Set数据<br>let  se = new Set([1,2,3]);//小括号内可以为空，传参必须为数组。</p><p>添加元素<br>let  se = new Set([1,2,3]);<br>se.add(4);//每次只能添加一个成员,返回的是Set数据本身</p><p>删除元素<br>let  se = new Set([1,2,3]);<br>se.delete(2);//返回的是布尔值，表示是否删除成功</p><p>查询元素<br>let  se = new Set([1,2,3]);<br>se.has(3);//表示是否有这个数字，返回的是布尔值</p><p>清除所有<br>let  se = new Set([1,2,3]);<br>se.clear();//清除所有成员</p><p>遍历<br>Set数据和数组一样有forEach方法可以遍历Set数据。</p><p>for …  of 遍历<br>for  of 可以遍历数组，字符串，Set数据。<br>let arr = [1,2,34,5];<br>for (let itme of arr){<br>    console.log(itme)// 1 2 34 5<br>}</p><p>使用for  of 不能直接遍历对象需要进行处理一下<br>let obj = {<br>             a: 1,<br>             b: 2,<br>             c: 3<br>         }<br>         for (let itme of Object.keys(obj)) {<br>             console.log(itme);<br>             console.log(obj[itme]);<br>         }</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/09/JS%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/02/09/JS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>第一天<br>计算机基础<br>计算机语言分为机器语言（0，1），汇编语言（简单的英语单词），高级语言（相对与低级语言又跟多的词汇更符合人类语言）<br>翻译器：使用汇编语言或者高级语言编写的代码计算机无法识别需要翻译器进行翻译后在执行。<br>编程语言：编程语言有很强的逻辑性和行为能力，是主动的<br>标记语言：没有什么逻辑，一般是由系统读取的，是被动的<br>计算机由软件和硬件组成：<br>       软件：系统软件（winds系统，linuk系统等），应用软件（qq，浏览器等）<br>       硬件：输入设备（键盘，鼠标等） 输出设备（显示器，音响等）CPU 主板 内存 硬盘。<br>计算机中数据都是以01的形式储存的。<br>储存单位：bit        （1bit储存一个0或1）<br>                 Byte     （1B=8b）<br>                 KB       （1KB=1024B）<br>                 MB      （1MB=1024KB）<br>                 GB      （1GB=1024MB）<br>                 TB       （1TB=1024GB）<br>js属于脚本语言，脚本语言不需要编译，运行中由js解释器进行翻译并执行。并且是逐行翻译执行。<br>js的作用：<br>表单动态校验（密码强度检测）  （ JS 产生最初的目的 ）<br>网页特效<br>服务端开发(Node.js)<br>桌面程序(Electron)<br>App(Cordova)<br>控制硬件-物联网(Ruff)<br>游戏开发(cocos2d-js)</p><p> JavaScript的组成：ECMASCript（js语法），DOM（页面对象模型），BOM（浏览器对象模型）<br>js书写分为：行内式，内嵌式，外联式和css相同。<br>注意：js引入写法为<script src="my.js"></script><br>js的注释：单行//（快捷键ctrl+/） 多行 /<em>内容</em>/（快捷键alt+shift+a，修改为shift+ctrl+/）</p><p>JavaScript输入输出语句<br>alert（内容）：浏览器弹出警示框<br>console.log（内容）：浏览器控制台打印输出信<br>prompt（提示）：浏览器弹出输入框，括号内可以写提示内容<br>注意：1.alert主要显示给用户，console主要显示给程序员，测试主要使用console<br>           2.alert提示框会中断js程序进程<br>           3.所有js代码内除了变量或者代码其他字母和文字都需要加引“”号。<br>           4.加了””引号的都是字符串类型数据。<br>           5.prompt输入框用户输入的内容都是字符串类型数据。<br>           6.写完一行代码最好用；隔开。</p><p>变量<br>变量实质上就是在内存上申请一块用于储存数据的空间，可以把变量当成一个存放数据的盒子。<br>var  num ：申明变量，申明一个名为num的变量<br>num = 10或者‘红色’，给num变量赋值为10或者红色<br>var num = 10 ； ：申明变量并赋值就是变量的初始化。<br>注意：同一个变量进行多次赋值，那么最后设置值会覆盖前面的值，可以同时申明多个变量<br>例：var num = 10 ；  var  num = 20 ；这时num的值会变成20<br>       var nu = 10 ， age = 20 ；同时申明多个变量，中间用，号隔开。<br>特殊情况：<br>只申明变量不赋值                      undefined（未定义）<br>只赋值不申明                             显示该值（不建议使用）<br>不申明不赋值，直接用               报错<br>变量的命名规范：<br>1.变量名由字母，数字，_，$组成，区分大小写<br>2.不能以数字开头<br>3.不能是关键字（and var 等）保留字<br>4.变量名必须有意义<br>5.遵循驼峰命名法，首字母小写，后面的单词首字母大写。</p><p>变量值的交换<br>先申明一个临时变量将a变量值放到临时变量中，再将b变量的值给它，最后将临时变量存放的值给b变量<br>例：var num1 = 10 ； var num2 = 20 ；var num3； num3=num1；num1=num2；num2=num3；</p><p>数据类型<br>Number：数字型<br>Boolean：布尔类型，true（真或等价1）false（假或等价0）<br>String：字符串型，字符串型都带引号 （‘ ’等价0）<br>Undefined：未定义<br>Null：空 （等价0）</p><p>数字进制<br>在js中数字前加0代标八进制，0x代标十六进制。<br>例： var num1 = 011 ； 对应十进制9；<br>        var num2 = 0xf ；对应十进制16；<br>Number.MAX_VALUE：最大值，1.796931348623157e+308<br>Number.MIN_VALUE：最小值，5e-32<br>linfinty：无穷大<br>-linfinty：无穷小<br>NaN：非数值</p><p>isNaN(值)：判断这个值是否是数字类型<br>                返回false则是数字类型<br>                返回true则不是数字类型</p><p>String字符串型<br>字符串型可以是引号中的任意文本，字符串型数据一定要用引号。<br>可以使用双引号套单引号反之亦然。<br>例： var age = ‘我是“高富帅”程序员’</p><p>字符串转义符<br>字符串中有些特殊的字符需要使用转义符显示。<br>\n ：换行转义符<br>\  ：斜杠<br>&#39;  ：单引号<br>&quot;  ：双引号<br>\t  ：缩进四个空格（对文字使用时会出现间距不对的问题）<br>\b ：空格</p><p>字符串长度<br>.length 检查字符串长度<br>例：var age = ‘字符串，长度’<br>      alert（age.length）；显示的数值是6<br>注意：空格和标点符号都算一个字符</p><p>字符串拼接<br>多个字符串之间可以使用+进行拼接<br>字符串+任何类型数据=拼接后的字符串<br>注意：+不可以写到引号内两个字符串分别需要用两个引号隔开<br>引号是匹配最近的引号进行将两者之间的数据包含。</p><p>布尔型Boolean<br>布尔型只有两个值 true和false，true表示真或者1，false表示假或者0<br>布尔型数据进行数字运算时true=1，false=0。</p><p>Undefine和Null<br>一个变量申明后没有赋值会有默认值undefined（未定义）<br>直接用会显示 ：undefined<br>与字符串相加显示 ：’字符串‘undefined<br>与数字和布尔型数据相加：NaN（非数字）</p><p>申明一个变量但是不赋值，则为空（Null）<br>直接用 ：显示null（空）<br>与字符串相加：‘字符串’变量名<br>与数字相加：等于原数字（Null相当于0）<br>与布尔型相加：与tru相加为1，与false相加为0.</p><p>获取变量类型<br>typeof 检测数据类型<br>例：var num = 18 ；<br>       console.log（typeof num）；结果是number。</p><p>字面量<br>​字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。<br>数字字面量：8, 9, 10<br>字符串字面量：’黑马程序员’, “大前端”<br>布尔字面量：true，false</p><p>数据类型转换<br>转换为字符串<br>.toString（）  例：var num = 1 ； consle.log（num.toString（））<br>String（）强制转换 例：console.log（String（num））<br>加号拼接字符串（隐性转换，建议使用） 例：console.log（num+‘’）<br>转换为数字型<br>parseInt（） 例：parseInt（‘234’）（只能转化整数部分，若以非数字开头则显示NaN，常用）<br>parseFloat（）例：parseFloat（‘23.33’）（可以保留小数，若以非数字开头则显示NaN，常用）<br>Number（）例：Number（‘12.33’）（强制转换，可以保留小数）<br>利用算数运算隐性转换 例：‘23’-0（保留小数）<br>转换为布尔型<br>Boolean（）例：Boolean（其他数据类型）<br>注意：代标空，否定的值会被转化为false，例：‘ ’、0、NaN、null、undefined<br>           其他都转换为true</p><p>第二天<br>一、运算符<br>1.运算符的分类<br>算数运算，递增和递减运算，比较运算符，逻辑运算符，赋值运算符</p><p>2.算数运算符</p><ul><li>（加）、 -（减）  、<em>（乘）  、 / （除） 、 % （取余，返回除法的余数）<br>运算顺序是先</em>、/ 后加减<br>注意：+号和字符串相连会进行拼接，其他类型数据隐式转换为字符串。<pre><code>   - 、 * 、/、% 和数字型相连会将其他类型数据隐式转换为数字型。  在进行算数运算时尽量避免小数运算，因为在计算机中运算小数需要先转换成二进制再进行运算会出现误差。小数最高精度为17位，所以进行小数运算时会有误差不准确。</code></pre>例：var result = 0.1 + 0.2;    // 结果不是 0.3，而是：0.30000000000000004<br>console.log(0.07 * 100);   // 结果不是 7，  而是：7.000000000000001<br>表达式：由变量，运算符，数字等能求得值的式子。<br>返回值：由表达式运算的结果返回给开发值的数据。</li></ul><p>3.递增和递减运算符<br>前置递增和递减运算符，只能和变量一起使用不能直接跟数字或者其他数据类型。<br>注意：递增和递减运算符也可以将其他数字类型隐式转换成数字型。</p><p> ++num ，–num ：相当于 num = num + 1 或者 num = num - 1<br>注意：前置运算符是先自加1或自减1，之后返回数值。</p><p>后置递增和递减运算符<br>num++  ，num–  ：相当于 num = num + 1 或者 num = num - 1<br>注意：后置运算是先返回数值之后，再进行加1或者减1。<br>       若 num=10；   num = num++  ；num 为10，不是11，因为num++是先返回值再计算</p><p>4.比较运算符<br>&lt;  （小于） &lt;=  （小于等于）  &gt;    （大于）  &gt;=  （大于等于）== （判断等号）<br> != （不等号） === （全等，需要数据类型也一样） !== （不全等）<br>注意：除了===全等和！==不全等其他比较运算符都会把其他类型数据转换成数字型再进行比较。</p><p>5.逻辑运算符<br>&amp;&amp;  ：逻辑与  两边都为true时结果才为，否则为false<br>例：true &amp;&amp; true （结果为true）true &amp;&amp; false （结果为false）</p><p>||   ：逻辑或  两边都为false时结果才为false，否则为true<br>例：false || false（结果为false） false || true （结果为true）</p><p>！ ：逻辑非，值取反，取一个布尔值的相反值，如true取反则是false。<br>注意：‘ ’、0、nul、undfined、NaN，这些特殊数据会转换成布尔类型里的false其他为true。</p><p>6.逻辑中断<br>在逻辑运算中有多个表达式时，当左边的表达式可以确定结果的时候就不会在继续运算，直接输出结果。</p><p>逻辑与的中断：当表达式1为假时则输出表达式1，之后的运算不再计算。若为真输出表达式2。如果后面只有一个表达式则直接输出最后一个表达式。<br>例：</p><script> var mun = 1 && 2 && 3 && 4 && 0 && 1 && 8 ; //num 为0 var age = 1 && 2 && 3 && 4 && 1 ; //num 为1</script><p>逻辑或的中断：当表达式1为真时则输出表达式1，之后的运算不再计算。若为假输出表达式2。如果后面只有一个表达式则直接输出最后一个表达式。<br>例：</p><script> var mun = 0 || 0 || 0 || 4 || 0 || 1 ; //num 为0 var age = 1 && 2 && 3 && 4 && 1 ; //num 为1</script><p>7.赋值运算符<br>=  ：直接赋值<br>+= 、-= 、*= 、/= 、% 、：先加、减、乘、除、取余后赋值。</p><p>8.优先级<br>1级 ： 小括号 （）<br>2级 ：一元运算符  ++num 、–num 、！true（只有一个变量的运算）<br>3级：算术运算符  先* 、/ 后加减<br>4级：比较运算符  &lt;  &gt; &lt;=  &gt;=<br>5级：相等运算符  == 、！= 、=== 、！==<br>6级：逻辑运算符 先&amp;&amp;后||<br>7级：赋值运算符 = 、+= 、-=、*=、/=、%=</p><p>二、流程控制<br>1.流程控制分为：顺序结构、分支结构、循环结构，是用来控制代码执行的顺序的。</p><p>2.顺序结构就是按照代码的书写顺序依次执行。</p><p>3.分支结构<br>分支结构根据不同的条件执行不同的代码。（多选一）<br>if语句<br>if （判断条件）{<br>     条件成立时执行的代码；<br>}<br>if语句双分支<br>if （判断条件）{<br>    条件成立时执行的代码；<br>} else {<br>     条件不成立时执行的代码；<br>}<br>if语句多分枝<br>if （判断条件）{<br>    条件成立时执行的代码；<br>} else if （判断条件） {<br>     条件成立时执行的代码；<br>} else {<br>     条件都不成立时执行的代码；<br>}</p><p>三元表达式<br>表达式1 ？ 表达式2：表达式3；<br>表达式1成立则输出表达式2，否则输出表达式3，类似与if双支语句。<br>例：12 &gt; 10 ？20 ：30；输出20.<br>注意：当进行两个字符串型的数字进行比较会出现错误的情况，最好将其中一个转换成数字型。原因是字符串进行比较时是一个字符和一个字符比较的。<br>例：‘abc’ &gt;‘abb’ ，‘5’ &gt; ‘100000’ ，结果都是true。  </p><p>switch分支流程控制<br>switch分支语句式根据不同的条件执行不同的代码，当变量的值是准确的值时可以使用switch分支语句。当变量的值不是准确的是一个范围建议使用if语句。</p><p>switch （表达式（通常是变量））{<br>           case 值/表达式 ：<br>           条件成立时的代码；<br>           break；（结束）<br>           case 值/表达式 ：<br>           条件成立时的代码；<br>           break；（结束）<br>           defult：<br>                     所有条件都不满足时执行的代码；<br>}<br>注意：如果执行case里的代码时没有break，则继续执行下一个case里面的代码直到有dreak为止。</p><p>第三天<br>一、循环语句<br>1.for循环语句<br>for循环语句用来多次执行某个代码。<br>for （初始化变量；条件表达式；操作表达式）{<br>      循环语句<br>}<br>初始化变量：用来记录循环次数<br>条件表达式：检查是否符合条件，符合则执行，不符合则退出循环。<br>操作表达式：用来限制循环次数避免死循环。<br>注意 ：不用循环的语句一定要写在循环语句外面。</p><p>2.双重循环语句<br>for （var i = 1； i &lt;= 100；i++）{<br>       for （var j =1；j&lt;=10；j++）{<br>          循环语句<br>        }<br>}<br>双重循环语句中外循环执行一次，内循环执行全部。</p><p>3.while循环语句<br>while循环语句与for一样符合条件表达式的进入循环，不符合则退出循环。<br>var i = 1；<br>while（条件表达式） {<br>     循环体；<br>     操作表达式<br>}</p><p>4.do while 循环语句<br>do {<br>  循环语句；<br>  操作表达式；<br>}  while （条件表达式）</p><p>5.continue，break<br>continue是跳出本次循环，之后的循环继续执行。<br>break是退出整个循环。<br>例： for (var i = 1; i &lt;= 5; i++) {<br>     if (i == 3) {<br>         continue; // 跳出本次循环，跳出的是第3次循环<br>    }<br>   }<br>跳过第三次循环，继续执行之后的循环。</p><p>for (var i = 1; i &lt;= 5; i++) {<br>     if (i == 3) {<br>         break; // 直接退出整个for 循环，跳到整个for下面的语句<br>     }<br>   }<br>跳出整个循环之后的循环不再执行。    </p><p>注意：若需要for，while循环没有达到想要的结果前一直循环可以使用一下方法：<br>for（ ；；），while（’true’）将break写在想要的结果的条件后面。<br>循环使用时代码的顺序也会影响结果。</p><p>第四天<br>一、数组<br>数组就是一组数据，将相关的数据放在一起，可以存放任何形式的数据。<br>数组内的数据被称为数组元素。</p><p>数组的命名<br>命名一个新的空数组变量<br>var 数组名 = new  Array（）；<br>通过数组字面量[]使变量成为数组变量。<br>var 数组名 = []；</p><p>数组元素的访问<br>var num = [1,2,34,5,8]<br>变量名[索引号]<br>num [0]  访问num数组中的第一个数据1<br>注意：索引号是从0开始</p><p>数组元素数量<br>通过.length 来获得一个数组中数组元素的个数。<br>length属性会随着数组元素个数变化而变化。</p><p>遍历数组<br>for (var i = 0 ; i &lt; num.length ; i++){<br>num[i]<br>}</p><p>数组反转<br>var arr = [1，2，3，4，5，6，7]；<br>var newArr = [];<br>for （var i = arr.length - 1 ;i &gt;= 0; i–）{<br>    newArr[newArr.length] = arr [i]<br>}</p><p>冒泡排序<br>var arr = [1,4,2,6,12,5];<br>for (var i = 0; i &lt; arr.length - 1 ; i++) {<br>    for (var j = 0; j&lt; arr.length - 1 -i; j++ ){<br>        if(arr[j] &gt; arr[j + 1]) {<br>            var tmp = 0;<br>            tmp = arr[j];<br>            arr[j] = arr[j + 1];<br>            arr[j + 1] = tmp;<br>        }<br>    }<br>}</p><p>数组中新增元素<br>通过索引号添加新数组元素<br>var num = [1，2，3，4]；<br>num[4] = 5；<br>通过length在数组后面添加新的空数组元素<br>num.length = 6；<br>注意：这种方法创建的新元素是空的。</p><p>二、函数</p><p>函数是封装了一段可以被重复调用的代码块。</p><p>函数的命名</p><ol><li>自定义函数<br>function 函数名 () {<br>//函数代码<br>}</li></ol><p>2.匿名函数（函数表达式）<br>var num = function () {<br>    //函数代码<br>}</p><p>函数的调用<br>函数名（）<br>注意：调用函数必须带上小括号。<br>          当函数里面套一个函数时，只能在外层函数内调用，在外层函数外不能调用。<br>         function num1() {</p><pre><code>        function num2(a, b) &#123;            return a * 0 + b * 0        &#125;        function num3() &#123;            function num4() &#123;                console.log(num2(1, 2));            &#125;            num4()        &#125;        num3()    &#125;    num1()</code></pre><p>函数的封装<br>function getSum () {<br>    var sumNum = 0;<br>    for (var i = 1; i &lt;=100; i++){<br>        sumNum += i;<br>    }<br>    return sumNum<br>}</p><p>函数的参数<br>函数有两个参数分别为形参和实参，函数可以有参数也可以没有。<br>function num (形参1，形参2…){<br>    console.log(形参1)<br>    console.log(形参2)<br>    …<br>}<br>num(实参1，实参2…)</p><p>实参和形参是一一对应的关系没有数量的限制，可以是数字，字符串或者其它类型数据，参数与参数之间用，隔开。</p><p>注意：当实参个数多于形参个数，则按顺序一一对应多余的实参不管。<br>          当实参个数小于形参个数，多的形参定义为undefined。</p><p>函数的返回值<br>函数执行后可以通过return返回指定数据。<br>return不仅可以返回数值还可以结束整个函数，在return后面的代码不会执行。<br>如果函数没有return返回数据，打印函数会先执行函数之后显示undefined。</p><p>continue：跳过当前循环<br>break：结束整个循环<br>return：结束循环并结束函数返回return值</p><p>arguments的使用<br>arguments实际上是函数的内置对象属于伪数组，可以接受所有传送的实参。<br>伪数组具有length属性和索引号访问，也可以通过for循环进行遍历。<br>但是不能使用数组里的push（在数组的最后开始添加元素），pop（在数组的最前面开始添加元素）等方法</p><p>第五天</p><p>一、作用域<br>作用域就是一段代码的名字在一定范围内有效，使代码更加的可靠减少命名冲突。（es6前的版本）<br>作用域分为：全局作用域和局部作用域。</p><p>全局作用域<br>在整个js文件或者script标签中都是有效的。</p><p>局部作用域<br>只在函数内有效的，又称为函数作用域。</p><p>块级作用域<br>es6之前的js是没有块级作用域的这时es6新增的。<br>在java和其它语言中有块及作用域。</p><p>块级作用域是用大括号{}包括的范围。<br>在块级作用域内申明的变量不能在{}大括号外访问。</p><p>变量的作用域<br>变量的作用域分为：全局变量，局部变量</p><p>全局变量<br>全局变量是指在全局作用域下申明的变量，可以在任何位置访问。<br>注意：若变量没有申明直接赋值也是全局变量，不建议使用。<br>           function num (){<br>               var a = b = c = 8;<br>           }</p><p>上述情况中变量b，c属于未申明直接赋值属于全局变量，a属于局部变量。赋值时从右往左进行赋值的。</p><p>局部变量<br>在局部作用域申明的变量或函数内申明的变量，只能在当前作用域下访问其他位置无法访问。<br>注意：函数中的形参也是属于局部变量。</p><p>作用域链<br>当一个函数内还有函数，根据内部函数可以访问外部函数变量的机制，用链式查找决定哪写数据能被内部函数调用，这就称之为作用域链。<br>作用域链总结就是，就近原则。通过就近原则来查找最终值。变量的赋值也是根据就近原则给最近的相同变量进行赋值。</p><p>二、预解析</p><p>浏览器执行流程<br>1.先进行语法校验，当语法校验不通过时则整个js都不会执行<br>2.语法校验通过后，进行预解析，将var（变量声明）function（函数申明）提升到当前作用域的最前面<br>注意：var提升的只是变量的声明，变量赋值并不会提升，而function提升是将整个函数提升到当前作用域最前面。但是在代码执行过程中我们不看函数申明只看函数调用，因为函数只有调用后才会执行。<br>3.按照从上到下的顺序依次执行。</p><p>三、对象</p><p>定义<br>万物皆对象，对象指某一个具体的事物。<br>在javascript中对象是一组无序的属性和方法的集合。<br>属性是这个事物的特征，比如一个人的身高，体重，性别等（常用名词）<br>方法是这个事物能做什么，比如一个可以打篮球，唱歌，写代码等（常用动词）</p><p>创建对象与调用<br>1.使用对象的字面量{}创建对象。<br>var obj = {<br>    nam : ‘小明’,<br>    sex : ‘男’,<br>    run : function (){<br>        console.log(‘跑步)<br>    },<br>    son : function (){<br>        console.log(‘微光’)<br>    }<br>}</p><p>注意：对象里的属性和方法使用键值对的方式书写方式   属性名（方法名）：属性值（方法）每个属性和方法后面用逗号’，’隔开。<br>属性名后面跟的是一个值，方法名后面跟的是函数。</p><p>2.函数的调用<br>属性值的调用<br>对象名.属性名   对象名[‘属性名’]（一定要加引号，中括号中可以是变量但是变量的值必须是属性名的字符串）<br>obj.nam;<br>obj[‘nam’];<br>var unam = ‘nam’;<br>obj[unam]</p><p>方法的调用<br>对象名.方法名（） 注意：中括号写法不能用来调用方法。<br>obj.run();</p><p>3.修改和新增对象属性或方法<br>属性值的修改：先调用属性然后进行重新赋值<br>注意：属性和方法永远不会重复，只会有一个，后面的数据会覆盖前面的数据。<br>obj.nam = ‘小红’;<br>obj[‘nam’] = ‘小红’;</p><p>新增属性：对象名.新的属性名 = 新的属性值<br>                 对象名[‘新的属性名’] = 新的属性值<br>obj.age = 18;<br>obj[‘age’]=18;</p><p>注意：新增属性其实做了两步操做，先新建一个属性然后进行赋值<br>方法的修改：先调用方法然后重新赋值<br>obj.run() = function () {<br>    console.log(‘拼命的跑’)<br>}</p><p>方法的新增：对象名.新增的方法名 = 新增的方法函数<br>obj.song() = function(){<br>    console.log(‘冰雨’)<br>}</p><p>4.构造函数创建对象<br>function Obj (nam,sex){<br>    this.nam = nam ;<br>    this.sex = sex ;<br>    this.run = function (txt){<br>        console.log(txt)<br>    }<br>}<br>var xiaoming = new Obj(‘小明’,’男’);//传入属性<br>xiaoming.run(‘跑步’)//传入方法</p><p>注意：构造函数名首字母大写，构造函数中如果使用的是this不需要写return返回值，会自动返回创建的对象<br>调用构造函数必须要写 new 才能创建新的对象<br>调用构造函数创建新的对象和使用函数一样，函数小括号里写形参，引用时小括号里写实参。<br>但是方法需要单独调用传入数据。<br>需要用一个变量接受这个对象。<br>构造函数创建的对象可以修改和新增属性但是不能修改和新增方法。</p><p>new关键字的作用（重点）<br>1.构造函数在开始执行之前，new关键字先在内存中申请一个空间在空间内存放创建的一个空对象<br>2.把所有this全部指向创建的空对象<br>3.通过this添加属性和方法传入新建对象中<br>4.将新建的对象返回给调用者</p><p>遍历对象<br>使用for…in …. 遍历对象<br>for (变量名 in 对象名) {<br>    console.log(变量名)//属性名<br>    console.log（对象名[变量名]）//属性值<br>}</p><p>注意：变量名通常为 var key 或者 var k 都可以，变量名实际上相当于对象里面的属性名<br>这里调用数值的只能使用中括号的方法，这种方法只能打印方法里的函数不会调用函数。</p><p>第六天<br>JavaScript中对象分为三种，自定义对象，内置对象，浏览器对象。<br>内置对象是js中本身就有的对象里面有一些常用的或者最基本且必要的功能。</p><p>由于内置对象很多所以需要学会查询文档来帮助我们了解这些内置对象<br>推荐MDN:   <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a> 查询。</p><p>一、Math对象（数学对象）<br>Math对象不是构造函数，它具有数学常数，和函数的属性和用法。跟数学相关的运算可以使用Math里的成员<br>1.Math.PI             圆周率（是一个固定的数值）<br>2.Math.fioor()       向下取整（括号内写入需要取整的数字，又称地板函数）<br>3.Math.ceil()         向上取整（同上，又称天花板函数）<br>4.Math.round()     四舍五入（同上，取最近的整数，注意：-3.5结果是-3，-3.54结果是-4 因为距离-4最近）<br>5.Math.abs()        取绝对值<br>6.Math.max()       求最大值（括号里的数字以逗号隔开，注意不可以使用数组只能输入数字）<br>7.Math.min()        求最小值（同上）<br>8.Math.random()  取[0，1)之间的随机浮点数（注意括号里不需要传参数）</p><p>指定范围内的随机数<br>Math.random();//[0，1)之间的随机浮点数<br>Math.random() * 15 ;//[0，15)之间的随机浮点数<br>parseInt(Math.random() * 15 );//[0，14]之间的随机整数<br>parseInt(Math.random() * (15 + 1));//[0，15]之间的随机整数<br>parseInt(5 + Math.random() * (15 - 5 + 1));//[5，15]之间的随机整数<br>function stochastic (a,b) {<br>    return parseInt(a + Math.random() * (b - a + 1));<br>}<br>//[a，b]的随机整数</p><p>注意这里的a是小于b的</p><p>二、日期对象<br>日期对象Date是一个构造函数，所以使用之前需要先调用Date创建新的对象才能使用。<br>1.获取当前时间对应的日期对象<br>var now = new Date();</p><p>2.获取指定日期对象<br>var now = new Date(‘2020-12-23’)<br>var now = new Date(‘2020/1/21’)<br>var now = new Date(‘2020-4-13 12:32:12’)</p><p>3.创建时间对象后可以获取该时间的年月日<br>now.getFullYear();//年<br>now.getMonth();//月，因为国外是从0开始计数所以得到的月数会少1需要+1<br>now.getDate();//日<br>now.getDay();//国外一周也是从0开始，0代标周日。</p><p>4.获取时间戳<br>now.valueOF();//获取目标原始值<br>now.getTime();//获取目标原始值（推荐使用）<br>+now;//一元加号，可以将其他数据类型转换成数字型（推荐使用）<br>+new Date();//同上，只是两种不同的写法（推荐使用）<br>Date.now();//HTML5中提供的方法，有兼容性问题</p><p>5.倒计时<br>var now = new Date();<br>funcion countDown(terminus) {<br>    var t1 = +now;//获取当前时间戳<br>    var t2 = +new Date(terminus);//获取目标时间的时间戳<br>    var time = parseInt((t2 - t1) / 1000);//计算时间差并换算成秒取整<br>    var h = time / 60 / 60 ;//将总共的秒数换算成小时数<br>    h = h &lt; 10 ? ‘0’ + h : h ;//倒计时通常是两位数显示所以小于10时需要补0<br>    var m = time / 60 % 60 ;//总秒数换算成分钟，进行取余得到不足一小时的部分<br>    m = m &lt; 10 ? ‘0’ + m : m ;//补0<br>   var s = time % 60 ;//取余得到不足一分钟的部分，因为不需要显示总共的秒数<br>   s = s &lt; 10 ? ‘0’ + s : s ;//补0<br>   return h + ‘:’ + m + ‘:’ + s;//输出结果<br>}</p><p>注释：count down ：倒计时<br>          terminus ：终点</p><p>三、数组对象<br>1.创建数组<br>创建数组有两种方法<br>字面量创建<br>var num = [1,2,4];</p><p>内置数组构造函数创建<br>var num = new Array()</p><p>使用构造函数创建新的数组不想要空数组可以在创造的时候传入参数即可。<br>注意：当传入多个参数时，传入的参数就是数组元素<br>          当传入一个参数时，则是规定了数组的长度</p><p>2.检查是否是数组<br>instanceof  运算符<br>使用方法：变量  instanceof  数据类型  ，变量数据类型和后面的数据类型相同返回true，否则返回false<br>num instanceof Array ;//检测是否是数组类型<br>num instanceof Function ;//检测是否是函数类型</p><p>Array.isArray() 判断<br>使用方法：将需要判断的变量名放入小括号内，是数组类型则返回true，否则返回false。<br>Array.isArray(num);//检测是否为数组类型</p><p>3.添加或删除数组元素方法<br>添加元素<br>push（参数1，参数2..） ：末尾添加元素，可以是多个，修改原数组，返回新数组长度<br>var num = [1,2,3,4];<br>num.push(2,3,4)</p><p>unshift（参数1，参数2..） ：在前面添加元素，可以是多个，修改原数组，返回新数组长度<br>var num = [1,2,3,4];<br>num.unshift(2,3,4);</p><p>删除元素<br>pop（）删除末尾的一个元素，修改原数组，返回被删除的元素<br>var num = [1,2,3,4];<br>num.pop();</p><p>shift（）删除末尾的一个元素，修改原数组，返回被删除的元素<br>var num = [1,2,3,4];<br>num.shift();</p><p>splice(起始位置，个数) 从起始位置开始，删除输入的个数，返回删除的元素组成的新数组，改变原数组<br>var num = [1,2,3,4];<br>num.splice(1,2);</p><p>数组的排序、翻转、查询<br>数组的排序<br>sort（）小括号内是一个函数，修改原数组，返回排序的数组<br>var num = [5,2,8,4];<br>num.sort(function (a,b){<br>    return a - b;//若 a - b 大于0则互换位置，否则不换，该成b - a 则是从大到小排序<br>})</p><p>数组的翻转<br>reverse（）小括号内不需要写参数。翻转数组，修改原数组，返回翻转后的数组<br>var num = [5,2,8,4];<br>num.reverse();</p><p>数组的查询<br>indexOf（）括号内写要查询的元素，从前查询该元素第一次出现的位置，返回索引号。<br>可以跟第二个参数，表示从该索引号开始查找<br>var num = [1,1,2,5,4,7,4,2,5];<br>num.indexOf(5);//结果为3<br>num.indexOf(5,4);//结果为8</p><p>lastIdexOf（）括号内写要查询的元素，从后查询该元素第一次出现的位置，返回索引号。<br>可以跟第二个参数，表示从该索引号开始查找<br>var num = [1,1,2,5,4,7,4,2,5];<br>num.lastIndexOf(5);//结果为8<br>num.lastIndexOf(5,7);//结果为3</p><p>注意：若该数组中没有该元素则返回-1。</p><p>数组去重<br>var num = [1,1,2,5,4,7,4,2,5];<br>var newNum = [];<br>for (var i = 0 ; i &lt; num.length; i++){//遍历数组num<br>    if (newNum.indexOf(num[i]) == -1 ){//判断新数组newNum有没有这个元素<br>        newNum.push(num[i]);//将没有的元素放入新数组中<br>    }<br>}</p><p>数组转换成字符串<br>var num = [‘a’,’b’.’c’,’d’]<br>num.join(‘+’)//括号内是转换成字符串时每个元素中间的间隔符，如果不需要就写一个空的字符串（推荐使用）<br>//结果是：a+b+c+d<br>num.toString()//括号内不需要写参数，转换成字符串默认用逗号隔开。<br>//结果是：a,b,c,d</p><p>注意：join如果不传参数默认以逗号隔开。两种方法返回的是字符串，不改变原数组。</p><p>数组的拼接<br>var num = [‘a’,’b’.’c’,’d’];<br>var num1 = [5,6,7,8];<br>var num2 = [1,2,3,4];<br>num.concat(num1,num2);</p><p>注意：返回的是拼接后的新数组，不影响原数组。</p><p>数组的截取<br>var num = [‘a’,’b’.’c’,’d’];<br>num.slice(起始位置,结束位置)//截取从起始位置开始到结束位置</p><p>注意：截取的元素包含起始位置但不包含结束位置，返回的是截取后的新数组，不改变原数组。</p><p>第七天<br>一、基本包装类型<br>之前使用length可以查询字符串的长度，但是length属性是只有对象才有的属性。之所以可以使用<br>是因为js会把简单数据类型包装成复杂数据类型就是对象。<br>基本包装就是把基本类型数据包装成复杂数据类型，这样基本数据类型就有了属性和方法。<br>使用String(),Number(),Boolean()。可以把相对应的基础数据类型包装成复杂数据类型。<br>js在包装基础数据类型时做了一下步骤：<br>var str =’afasfasfasdf’;<br>str.length;//当查询字符串长度时<br>var tamp = str.String();//将基础变量转换成复杂数据类型并赋值给临时变量<br>tamp.length;//将临时变量的length长度值返回给调用者<br>tamp = null;//将临时变量赋值为空，之后由内存清理机制进行销毁</p><p>二、字符串相关</p><p>字符串的不可变性<br>在js中字符串变量的值，就是字符串是不会改变的。虽然重新对变量赋值看上去对应的字符串变了，但实际上只是将地址改变了之前的字符串依然保存在内存里。当大量操作字符串会导致资源浪费。<br>所以在实际操作中应当尽量避免过多的操作字符串造成资源浪费。</p><p>根据字符返回具体位置<br>字符串根据基本包装类型可以调用部分方法操作字符串。<br>var str = ‘asdfasjdflkjasdf’;<br>str.indexOf(‘d’);//从前开始查找，返回查找到第一d出现的索引号，没找到返回-1<br>//可以跟第二个参数，第二个参数是从什么位置开始查找。<br>//同理lastIndexOf也可以使用。</p><p>案例：查找字符串中某个字符出现次数：<br>var str = ‘asdfasjdflkjasdf’;<br>var n = 0;//申明一个变量接收查询字符的索引号<br>var num = [];//申明一个变量储存每次查询的索引号<br>while(true){//设置死循环，因为不知道要循环几次<br>    n = str.indexOf(‘d’,n);//保存查询到的索引号<br>    if (n == -1) {//判断结束循环条件<br>        break;<br>    } else {//将查询到的索引号保存。<br>        num.push(n)<br>    }<br>    n++//更改起始位置<br>}</p><p>根据位置返回字符串<br>1.索引号方式获取<br>var str = ‘qwertyui’;<br>str[3]//结果为’r’</p><p>2.使用.charAt()方式获取<br>var str = ‘sdkfjhas’;<br>str.charAt(4);//结果为‘j’</p><p>3.使用.charCodeAt()方法获取的是该字符所对应ASCII码，ASCII码是用来判断用户按的是哪个按键。</p><p>案例：判断出现最多的字符和次数<br>var str = ‘ asdfsdfasdfd’;<br>var arr ={};//创建对象用来储存变量中的字符和出现的次数<br>for (var i = 0 ; i &lt; str.length; i++) {<br>    var strt = str[i];//<br>    if (arr[strt]) {//判断arr对象中是否有这个字符对应的属性，有则加一<br>        arr[strt]++<br>    } else {//没有则创建这个字符属性并赋值<br>        arr[strt] = 1;<br>    }<br>}<br>var max = 0 ;//设置变量储存最大值<br>var maxId = ‘’;//设置变量储存最大值对应的字符<br>for (var kay in arr) {//遍历对象<br>    if (arr[kay] &gt; max){//判断最大值，若大于则对max，和maxI重新赋值<br>        max = arr[kay];<br>        maxId = kay;<br>    }<br>}<br>console.log(max,maxId)</p><p>字符串操作方法<br>字符串.concat(字符串1，字符串2)  :用来拼接多个字符串相当于+，但是+更常用<br>var str = ‘fasdf’;<br>var str1 = ‘sadf’;<br>var str2 = ‘gdfgf’;<br>str.concat(str1,str2)//返回的是拼接后新的字符串</p><p>字符串的截取<br>.slice(起始位置，终止位置)，与数组的截取一样从起始位置开始（包含）到终止位置（不包含）的字符，可以是负值。为负值时是从后往前<br>var str = ‘fasdf’;<br>str.slice(0,3)</p><p>注意：一下方法数组无法使用</p><p>.substr(起始位置，截取个数)，从起始位置开始截取设置个数的字符<br>var str = ‘fasdf’;<br>str.substr(0,3)</p><p>.substring(起始位置，终止位置)，与数组的截取一样从起始位置开始（包含）到终止位置（不包含）的字符，不可以是负值<br>var str = ‘fasdf’;<br>str.substring(0,3)</p><p>字符串的替换<br>.replace(被替换的字符，要替换的字符) ，替换的是第一个符合条件的字符。<br>var str = ‘fasdf’;<br>str.replace(‘a’,’sadf’)</p><p>字符串转换成数组<br>split(‘分割字符’) ：将字符串根据分割字符分割为数组，若字符串没有分割符则写空字符‘’即可<br>var str = ‘fasdf’;//没有分割符<br>str.split(‘’)<br>var str1 = ‘a1c1f1g1h1d’//有分割符<br>str1.split(‘1’)</p><p>三、简单数据类型和复杂数据类型       </p><p>1.简单数据类型<br>简单数据类型在储存时变量中储存的是值本身</p><p>2.复杂数据类型<br>复杂数据类型在储存时变量中储存的其实是一个十六进制的地址值</p><p>3.堆和栈<br>栈 ：由操作系统自动分配和释放，用于存储简单数据类型的变量值、局部变量值、变量名和复杂数据类型的地址<br>存储方式：</p><p>堆：由程序员分配和释放，如果程序员没有释放则由垃圾回收机制回收，用于存放复杂数据类型本身。<br>存储方式：</p><p>4.传参方式<br>简单数据类型变量传递的实际上是值本身<br>复杂数据类型变量传递的是十六进制的地址值</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/01/28/hello-world/"/>
    <url>/2021/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
