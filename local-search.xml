<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mySQL 命令</title>
    <link href="/2021/02/24/mySQL%20%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/24/mySQL%20%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>通过 * 把 users 表格内的所有数据查询出来。<br>注意：如果需要运行多行代码需要在每行代码后加 ; 号</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users;<br></code></pre></td></tr></table></figure><p>从 users 表中将 username 列中的数据查询出来,多个列查询用 , 逗号分割</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> users;<br></code></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>向 users 表中插入数据,列和值是一一对应的。列名之间用逗号分割，值同上<br>使用 value 只能插入一行数据， values 可以同时插入多行数据，所以建议使用 values</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users(username, <span class="hljs-keyword">password</span>) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;xh1&#x27;</span>, <span class="hljs-string">&#x27;09831&#x27;</span>), (<span class="hljs-string">&#x27;xh2&#x27;</span>, <span class="hljs-string">&#x27;09831&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users(username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">value</span>(<span class="hljs-string">&#x27;小红&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>通过 update 修改 id 为 5 的用户密码修改为 888888,注意一定要加 where 条件否则会修改全部数据</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update<span class="hljs-built_in"> users </span><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;888888&#x27;</span> where <span class="hljs-attribute">id</span>=5;<br></code></pre></td></tr></table></figure><p>更改一行多个列的数据,多列数据之间用逗分割 更新 id=4 用户的 password 和 status</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update<span class="hljs-built_in"> users </span><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;000000&#x27;</span>,status=1 where <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;小红&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>使用 delete 删除表内的指定数据，注意一定要加 where 条件否则会是删除全部数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id=<span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><h2 id="演示-where-子句"><a href="#演示-where-子句" class="headerlink" title="演示 where 子句"></a>演示 where 子句</h2><p>查询 status=0 的数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> status=<span class="hljs-number">0</span>; <br></code></pre></td></tr></table></figure><p>查询 id&gt;2 的数据             </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id&gt;<span class="hljs-number">2</span>;     <br></code></pre></td></tr></table></figure><p>查询 status 值不等于 0 的数据         </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> status &lt;&gt;<span class="hljs-number">0</span>;   <br></code></pre></td></tr></table></figure><p>查询 status 值不等于 1 的数据     </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> status != <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>查询 id 值 在 1 到 4 之间的数据(包含1和4)    </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id <span class="hljs-keyword">between</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">4</span>;    <br></code></pre></td></tr></table></figure><p>查询 password 值中以 1 结尾的数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%1&#x27;</span>;   <br></code></pre></td></tr></table></figure><p>查询 password 值中以 1 开头的数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;1%&#x27;</span>;    <br></code></pre></td></tr></table></figure><p>查询 password 值中包含 1 的数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%1%&#x27;</span>;   <br></code></pre></td></tr></table></figure><h2 id="and-和-or-条件子句"><a href="#and-和-or-条件子句" class="headerlink" title="and 和 or 条件子句"></a>and 和 or 条件子句</h2><p>使用 and 查询 tatus=0 并且 id&lt;3 的数据， and 表示多个条件都满足的数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> status=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> id&lt;<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>使用 or 查询 tatus=0 或者 id&lt;3 的数据， or 表示多个条件中只要满足其中一个的数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> status=<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> id&lt;<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>使用 order by 对数据进行排序<br>查询所有数据，并按照 status 值升序排序,默认升序</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> status <span class="hljs-keyword">asc</span>;  <br></code></pre></td></tr></table></figure><p>查询所有数据，并按照 status 值降序排序</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> status <span class="hljs-keyword">desc</span>; <br></code></pre></td></tr></table></figure><p>多重排序: 查询所有数据， 先按照 status 升序排序，后按照 id 降序排序</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> status <span class="hljs-keyword">asc</span>,id <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>注意: 当同时使用 where 和 order by 时，需要将 order by 写在 where 后面。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id&gt;<span class="hljs-number">2</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>返回匹配的数据行数</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*) <span class="hljs-keyword">from</span> users;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>npm 命令</title>
    <link href="/2021/02/22/npm%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/22/npm%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="npm-相关命令"><a href="#npm-相关命令" class="headerlink" title="npm 相关命令"></a>npm 相关命令</h2><p>下载指定包 </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> 包名<br></code></pre></td></tr></table></figure><p>简写</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i 包名<br></code></pre></td></tr></table></figure><p>下载指定版本的包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> 包名@指定版本<br></code></pre></td></tr></table></figure><p>简写</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i 包名@指定版本<br></code></pre></td></tr></table></figure><p>查看指定包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> view 包名<br></code></pre></td></tr></table></figure><p>快速创建包管理配置文件 package.json </p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init -y<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>该命令必须在项目的根目录下执行</li><li>项目目录名不能包含汉字或者空格</li><li>package.json 文件在每次安装包时都会记录包名和版本不需要手动修改</li></ul><p>下载所有需要的包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>简写</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i <br></code></pre></td></tr></table></figure><p>卸载指定包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall 包名<br></code></pre></td></tr></table></figure><p>安装开发测试阶段的包，-D和包名没有顺序要求</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> 包名@版本号<br></code></pre></td></tr></table></figure><p>简写</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D 包名@版本号<br></code></pre></td></tr></table></figure><p>查看npm 包下载源</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">get</span> registry<br></code></pre></td></tr></table></figure><p>修改npm 包下载源</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">registry</span>=https://registry.npm.taobao.org/<br></code></pre></td></tr></table></figure><p>下载nrm 工具并配置到全局</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -g nrm<br></code></pre></td></tr></table></figure><h2 id="使用nrm-查看所有下载源，带星号的为当前下载源"><a href="#使用nrm-查看所有下载源，带星号的为当前下载源" class="headerlink" title="使用nrm 查看所有下载源，带星号的为当前下载源"></a>使用nrm 查看所有下载源，带星号的为当前下载源</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nrm ls</span><br></code></pre></td></tr></table></figure><p>使用nrm 查修改下载源</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">nrm <span class="hljs-keyword">use</span> 下载源名称<br></code></pre></td></tr></table></figure><p>下载全局包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -g 包名<br></code></pre></td></tr></table></figure><p>卸载全局包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall -g 包名<br></code></pre></td></tr></table></figure><p>下载将 md 文件转换成 html 文件的工具</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> i -g i<span class="hljs-number">5</span>ting_toc<br></code></pre></td></tr></table></figure><h2 id="i5ting-toc"><a href="#i5ting-toc" class="headerlink" title="i5ting_toc"></a>i5ting_toc</h2><p>将 md 文件转换成 html 文件</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-type">i5ting_toc</span> <span class="hljs-operator">-</span><span class="hljs-variable">f</span> <span class="hljs-built_in">URL</span> <span class="hljs-built_in">File</span><br></code></pre></td></tr></table></figure><p>URL为待转换的 md 文件路径<br>File 为转换后的文件名称</p><p>将 md 文件转换成 html 后打开默认浏览器预览</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">i5ting_toc -f <span class="hljs-built_in">URL</span> -o<br></code></pre></td></tr></table></figure><p>登录 npm 官网</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> login <br></code></pre></td></tr></table></figure><p>注意：登录 npm 官网需要将下载源修改为 npm 官网地址  </p><p>发布自己的包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> publish<br></code></pre></td></tr></table></figure><p>注意：该命令在需要发布包的目录下执行  </p><p>删除自己发布的包</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm publish 包名 <span class="hljs-comment">--force</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模块加载机制</title>
    <link href="/2021/02/22/npm%20%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/22/npm%20%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h2><p>模块在加载后会进行缓存，如果再次执行加载模块命令如果缓存中已经有该模块则直接从缓存中返回相同队形不会导致模块被多次执行。提高了运行速度。</p><h2 id="内置模块的加载机制"><a href="#内置模块的加载机制" class="headerlink" title="内置模块的加载机制"></a>内置模块的加载机制</h2><p>内置模块拥有最优先的加载等级，即使有同名的模块也会优先加载内置模块</p><h2 id="自定义模块加载机制"><a href="#自定义模块加载机制" class="headerlink" title="自定义模块加载机制"></a>自定义模块加载机制</h2><p>加载自定义模块时必须带有 /  ./ 或者 ../ 否则 node 会默认它是内置模块或者 node_modules 目录下第三方模块进行加载</p><h3 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h3><ol><li>按照确切的文件名查找</li><li>在文件名后补充 .js 后缀查找</li><li>在文件名后补充 .json 后缀查找</li><li>在文件名后补充 .node 后缀查找</li><li>查找不到报错<h3 id="自定义目录模块"><a href="#自定义目录模块" class="headerlink" title="自定义目录模块"></a>自定义目录模块</h3>在加载目录下查找 package.json 文件，并寻找 main 属性作为入口加载<br>如果没有 package.json 文件或者 main 属性则试图加载 index.js 或者 index.node 文件。都没有则报错。</li></ol><h2 id="第三方模块的加载机制"><a href="#第三方模块的加载机制" class="headerlink" title="第三方模块的加载机制"></a>第三方模块的加载机制</h2><p>从当前模块的父级目录查找 /node_modules 目录里加载模块，如果当前没有则再向上查找直到文件系统的根目录</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jquery</title>
    <link href="/2021/02/09/jquery/"/>
    <url>/2021/02/09/jquery/</url>
    
    <content type="html"><![CDATA[<p>第一天<br>一、jQuery介绍</p><p>JavaScript库<br>javaScript库：指的就是library（仓库），一个封装好的特定的集合（方法和函数）。在库中封装好了一系列函数和方法。<br>常见的javaScript库：jQuery，Prototype，等等</p><p>JQuery的概念<br>JQuery是一个快速，简洁的javaScript库，其设计的宗旨就是“weite Less ， Do More”（写更少的代码，做更多的事）。</p><p>jQuery的下载<br>Query的官网地址： <a href="https://jquery.com/%EF%BC%8C%E5%AE%98%E7%BD%91%E5%8D%B3%E5%8F%AF%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E3%80%82">https://jquery.com/，官网即可下载最新版本。</a><br>各个版本的下载：<a href="https://code.jquery.com/">https://code.jquery.com/</a></p><p>版本介绍：<br>1x ：兼容 IE 678 等低版本浏览器， 官网不再更新<br>2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新<br>3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本</p><p>二、JQuery使用</p><p>Jquery的入口函数<br>jQuery中常见的两种入口函数：<br>第一种<br>$(document).ready(function(){<br>DOM加载完成的入口<br>})<br>第二种<br>$(function(){<br>DOM加载完成的入口<br>})</p><p>总结：<br>1.当DOM结构渲染完毕即可执行内部代码，相当于js中的DOMContentLoaded。<br>2.建议使用第二种方法更简洁方便。</p><p>JQuery中的顶级对象$</p><p>在JQuery中$是jQuery的别称，使用时$可以用jQuery代替，但一般为了方便通常就用$符号。<br>$时jQuery中的顶级对象相当于js中的window。$是将原生元素进行包装就成了jQuery对象，可以调用jQuery的方法。</p><p>jQuery对象和DOM对象</p><p>使用jQuery方法获取的元素就是jQuery对象，用原生的DOM方法获取的元素就是原生对象。两者是不一样的，jQuery对象本质上是对DOM对象进行包装后的对象（以伪数组的形式储存）<br>注意：只有jQuery对象才能使用jQuery方法，不能使用DOM原生方法。而DOM元素只能使用原生方法不能使用jQuery方法。<br>在jQuery中基本都是方法所以要加（）</p><p>jQuery对象和DOM对象的转换</p><p>jQuery对象转换成DOM对象<br>第一种<br>jQuery获取的元素是以伪数组的形式储存的，所以可以通过索引的方式获取DOM元素<br>let box = $(‘div’)[0]<br>第二种<br>通过jQuery的get(索引值)方法获取<br>let box = $(‘div’).get(0)</p><p>DOM元素转换成jQuery对象<br>let box = document.querySelector(‘div’);<br>使用$符号对原生对象进行包装即可<br>let JQbox = $(box);</p><p>jQuery选择器</p><p>基础选择器<br>$(‘选择器’)，引号里面直接写css选择器即可，支持css的各种选择器。</p><p>筛选选择器<br>语法 用法 用途<br>first $(‘li:first’)或$(‘li’).first() 获取第一个li元素<br>last $(‘li:last’)或$(‘li’).last() 获取最后一个li元素<br>eq() $(‘li:eq(2)’)或$(‘li’).eq(2) 获取索引号为2的li元素<br>odd $(‘li:odd’)或$(‘li’).odd() 获取索引号为奇数的元素<br>even $(‘li:even’)或$(‘li’).even() 获取索引号为偶数的元素</p><p>其他筛选器<br>语法 用法 用途<br>parent $(‘li’).parent() 获取父级元素<br>parents $(‘li’).parents() 获取所有的祖先级元素<br>childern $(‘li’).childern() 获取子级元素<br>find $(‘li’).find() 获取所有子孙元素<br>siblings $(‘li’).siblings() 获取所有兄弟元素，除了自身<br>prev $(‘li’).prev() 获取相邻的上个元素<br>pervAll $(‘li’).pervAll() 获取所有上个元素<br>next $(‘li’).next() 获取相邻的下个元素<br>nextAll $(‘li’).nextAll() 获取所有下个元素<br>注意：以上获取多个元素的方法小括号里都可以写上选择器来确定某个元素。</p><p>知识铺垫</p><p>jQuery设置样式<br>第一种<br>$(‘div’).css(‘属性’,’值’)<br>第二种<br>$(‘div’).css({<br>属性:值,<br>属性:值<br>})</p><p>注意：<br>第一种写法中属性和值都需要加引号，当值为数字时可以不用加引号<br>第二种写法中属性不需要加引号，值为数字时不需要加引号并且可以省略单位，但是值为字母时需要加引号，且当数字后面加单位或者%号也要加引号。</p><p>iQuery中的排他思想<br>对当前元素进行设置，然后将其他兄弟元素样式清空<br>$(this).css(‘color’,’red’);<br>$(this).siblings().css(‘color’,’’);</p><p>隐式迭代<br>//遍历获取到的所有元素的过程叫做隐式迭代<br>//就是给所有匹配到的元素进行循环遍历，简化了我们的操作<br>$(‘div’).hide()//给页面中所有的div隐藏，不需要再进行遍历</p><p>链式编程<br>//链式编程是为了节省代码量<br>$(this).css(‘color’,’blue’).siblings().css(‘color’,’blue’);<br>//将自身颜色改成蓝色，再将所有兄弟元素改为蓝色。</p><p>注意：在使用链式编程时，下个事件所在节点是上个事件结束后所在的节点<br>$(this).hide().parent().show().siblings(‘.box’).css(‘color’,’blue’);<br>//将自身隐藏，将父级显示，将父级的兄弟元素类名为box的元素颜色改为蓝色</p><p>设置类名<br>添加<br>$(‘div’).addClass(‘box’);<br>删除<br>$(‘div’).removeClass(‘box’);<br>切换<br>$(‘div’).toggleClass(‘box’);</p><p>注意：jQuery中操作类名不会对原先的类名产生影响。</p><p>显示隐藏</p><p>显示隐藏</p><p>显示<br>$(‘div’).show(time,speed,fn)<br>//显示div<br>//time 可省略参数，表示动画时间，省略表示无动画，<br>//预定义参数字符串（‘slow’，‘normal’，‘fast’）<br>//speed 可省略参数，表示动画的速度曲线<br>//fn 可省略参数，表示动画结束后执行该函数</p><p>隐藏<br>$(‘div’).show(time,speed,fn)<br>//同上</p><p>切换<br>$(‘div’).toggle(time,speed,fn)<br>//同上</p><p>注意：一下显示隐藏切换time动画时间默认为400<br>滑入滑出<br>下滑显示<br>$(‘div’).slideDown(time,speed,fn);<br>上拉隐藏<br>$(‘div’).slideUp(time,speed,fn);<br>切换<br>$(‘div’).slideToggle(time,speed,fn);</p><p>淡入淡出<br>淡入<br>$(‘div’).fadeIn(time,speed,fn);<br>淡出<br>$(‘div’).fadeOut(time,speed,fn);<br>切换<br>$(‘div’).fadeToggle(time,speed,fn);<br>到达指定透明度<br>$(‘div’).fadeTo(opacity,time,speed,fn);<br>//opacity 透明度，必填</p><p>自定义动画<br>element.animate(obj,speed,easing,fn);<br>//obj：想要更改的样式属性，以对象的形式传递，必须填写，属性性名不用带引号，<br>//如果是符合型写法需要采取驼峰命名法书写，其他参数可以省略</p><p>注意：jQuery中的自定义动画只能对值是数字类型的属性进行动画。并且无法对window添加自定义动画，可以对thml或者body添加</p><p>停止动画排队<br>动画或者效果一旦触发就会执行并且多次触发不会停止之前的动画，会进行排队。<br>停止动画排队的方法为：stop()；<br>element.stop().animate(obj,speed,easing,fn)<br>$(‘div’).stop().slideDown(time,speed,fn);</p><p>事件切换</p><p>jQurey中为我们添加了新的事件 hover ，功能类似css中的伪类选择器 :hover</p><p>语法<br>$(‘div’).hover(fn1(){},fn2(){});<br>//鼠标经过处理函数写在fn1，鼠标离开事件处理函数写在fn2</p><p>注意：如果只写一个函数那么鼠标经过和离开都会触发</p><p>mouseenter 和 mouseleave 事件<br>mouseenter事件和mouseover 事件类似，都是鼠标经过触发事件，不同点时mouseenter 不会进行冒泡。</p><p>mouseleave事件和mouseout事件类似，都是鼠标经过触发事件，不同点时mouseenter不会进行冒泡。</p><p>第二天</p><p>1.jQuery操作属性</p><p>元素固有属性值prop()</p><p>获取属性<br>$(‘div’).prop(‘属性名’)</p><p>设置属性<br>$(‘div’).prop(‘属性名’,’属性值’)</p><p>注意：prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。</p><p>自定义属性值attr()</p><p>获取自定义属性<br>$(‘div’).attr(‘属性名’)//类似原生getAttribute</p><p>设置自定义属性<br>$(‘div’).attr(‘属性名’,’属性值’)//类似原生setAttribute</p><p>注意：和原生的方法一样，attr()也可以获取和设置元素固有属性</p><p>数据缓存data()</p><p>data()方法可以在指定元素上存取数据，并不会修改DOM元素结构，在结构上是看不到的。页面刷新存储的数据就会消失。</p><p>附加数据<br>$(‘div’).data(‘name’,’value’)</p><p>获取数据<br>$(‘div’).data(‘name’)</p><p>注意：data() 方法也可以用来获取H5自定义属性data-index，得到的是数字型</p><p>2.jQuery文本属性值</p><p>jQuery内容文本值</p><p>元素内容<br>获取元素内容<br>element.html()//类似原生的innerHTML<br>设置元素内容<br>element.html(‘内容’)</p><p>文本内容<br>获取元素内容<br>element.text()//类似原生的innerText<br>设置元素内容<br>element.text(‘内容’)</p><p>表单的值val()<br>获取表单内容<br>element.val()//类似原生的value()<br>设置表单内容<br>element.val(‘内容’)</p><p>3.jQuery元素操作</p><p>遍历元素</p><p>方法1</p><p>$(‘div’).each(function(index,item){});</p><p>1.each方法主要是用来遍历匹配的每一个元素，遍历的是原生DOM元素<br>2.回调函数中有两个参数，index是每个元素的索引号，item是每个原生对象<br>3.想要对item使用jQ方法需要转化成jQ对象</p><p>方法2<br>$.each(obj,function(index,item){})</p><p>1.$.each方法可以遍历任何对象，主要用来处理数据。<br>2.回调函数有两个参数，index表示成员的索引号，item表示每个成员<br>3.用此方法遍历获取的对象，item表示的是原生对象需要转化。</p><p>创建，添加，删除</p><p>创建<br>$(‘<li></li>‘)</p><p>创建一个li标签</p><p>添加<br>element.append(‘内容’)</p><p>把内容放入匹配元素内最后面，类似原生的appendChlid方法<br>element.preppend(‘内容’)</p><p>把内容放入匹配元素内最前面<br>element.after(‘内容’)</p><p>把内容放入匹配元素的后面<br>element.before(‘内容’)</p><p>把内容放入匹配元素的前面面</p><p>删除<br>element.remove()</p><p>删除目标元素（包括自身）<br>element.empty()</p><p>删除目标元素的所有子节点（不包括自身）<br>element.html(‘’)</p><p>清空目标元素的内容</p><p>4.jquery尺寸和位置操作</p><p>jQuery尺寸操作</p><p>语法<br>语法 用法<br>width() / height()  获取元素的宽度和高度，只计算设置的宽高<br>innerWidth()  /  innerHeight() 获取元素的宽高，包含padding值<br>outerWidth()  /  outerHeight() 获取元素宽高，包含padding和border值<br>outerWidth(true)  /  outerHeight(true) 获取元素宽高，包含padding、border和margin<br>注意：以上返回值都是数字类型<br>参数为空，则是获取相应值<br>参数为数字则是修改值，参数可以不用写单位</p><p>jQuery位置操作</p><p>语法<br>语法 用法<br>offset() （1）offset 方法获取或设置被选中元素相对于文档的偏移坐标，跟父级没有关系（2）该方法有两个属性，offset().top  获取元素距离文档顶部的距离，offset().left  获取元素距离文档左侧的距离（3）可以设置元素的偏移：offset({top:10,left:20})<br>position() （1）position 方法获取或设置被选中元素相对于带有定位父级（包括祖先级）的距离，如果没有则以文档为准（2）该方法有两个属性，offset().top  获取元素距离带有定位父级顶部的距离，offset().left  获取元素距离带有定位父级左侧的距离（3）该方法只能获取不能设置<br>scrollTop() /  scrollLeft() （1）scroll 方法设置或获取元素被卷去的长度（2）不跟参数是获取，跟数字参数是设置</p><p>第三天 </p><p>jQuery事件注册</p><p>语法<br>element.事件名(function(){})<br>$(‘div’).click(function(){})</p><p>注意：事件名不需要加 on ，其他事件一样</p><p>事件处理on() 绑定事件</p><p>语法<br>绑定多个事件<br>$(‘div’).on({<br>click:function(){},<br>mouseover:function(){},<br>mouseout:function(){}<br>});<br>如果事件处理函数相同<br>$(‘div’).on(‘click mouseover mouseout’,function(){})<br>事件委托<br>$(‘div’).on(事件,触发元素,事件处理函数)<br>$(‘div’).on(‘click’,’a’,function(){})</p><p>事件处理off()解绑事件</p><p>语法<br>$(‘div’).off()//解绑div上所有的事件<br>$(‘div’).off(‘click’)//解绑div上的点击事件<br>$(‘div’).off(‘click’,’li’)//解绑事件委托</p><p>如果有的事件只想触发依次可以使用 one() 来绑定事件（了解）</p><p>自动触发事件trigger()</p><p>语法<br>$(‘div’).lick()//简写形式<br>$(‘div’).trigger(‘click’)//第一种自动触发<br>$(‘div’).triggerHandler(‘click’)//第二种自动触发</p><p>注意：triggerHandler方法不会触发元素的默认行为，和前两种不同。</p><p>jQuery事件对象</p><p>jQuery对DOM中的事件对象event进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发就会有事件对象的产生。</p><p>语法<br>element.click(function(event){<br>    event.preventDefault()或者return false//阻止默认行为<br>    event.stopPropagation() //阻止事件冒泡<br>})</p><p>jQuery拷贝对象</p><p>语法<br>$.extend(deep,target,obj1,objN)</p><p>1.deep：可以设置为false或者true，true为深拷贝，默认为false浅拷贝<br>2.target：要拷贝数据的对象<br>3.obj1：被拷贝的对象<br>4.objN：被拷贝的第N个对象<br>注意：浅拷贝会拷贝对象中的属性，改变对象中的属性值不会改变目标对象。而拷贝对象中的复杂数据类型只会复制复杂数据类型的地址，改变对象中的复杂数据也会修改目标对象对应的数据。<br>同一属性名的值会被后者覆盖</p><p>jQuery多库共存（了解）</p><p>实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。</p><p>语法<br>var hh =  $.noConflict()<br>将jQuery变量重新命名为hh</p><p>jQuery插件</p><p>jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入<br>jQuery文件，因此也称为 jQuery 插件。<br>​    jQuery 插件常用的网站：<br>jQuery 插件库  <a href="http://www.jq22.com/">http://www.jq22.com/</a><br>jQuery 之家   <a href="http://www.htmleaf.com/">http://www.htmleaf.com/</a><br>jQuery 插件使用步骤：<br>引入相关文件。（jQuery 文件 和 插件文件）<br>复制相关html、css、js (调用插件)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WAB API</title>
    <link href="/2021/02/09/WAB%20API/"/>
    <url>/2021/02/09/WAB%20API/</url>
    
    <content type="html"><![CDATA[<p>第一天<br>一、Api介绍<br>api是一些预定好的函数，目的是提供应用程序和程序员基于软件或硬件访问一组例程的能力。<br>简单来说就是一种工具方便程序员实现想要的功能。<br>就像是手机的充电口和充电线一样。我们不需要了解内部的运行原理只需要能够熟练运用即可。</p><p>web Api<br>web Api是浏览器提供的一系列操作浏览器窗口和页面元素的接口。</p><p>DOM文本对象模型<br>文本对象模型是w3c组织推荐的处理可扩展标记语言（html或xhtml）的标准接口。</p><p>DOM树</p><p>在DOM中最大的元素就是文档（document），文档包含html和里面的所有元素。<br>文档：文档就是一个页面，在DOM中用document表示；<br>节点：文档内所有内容都是节点，用node表示，例如标签，属性，文本，空格等等都可以看作一个节点。<br>元素节点：文档内所有的标签都是元素节点，用element表示<br>属性节点：所有标签的属性称为属性节点</p><p>二、获取元素方法</p><p>1.根据ID获取元素<br>document.getElementByID(‘id名’)</p><div id="box">123</div>;var box = document.getElementByID('box');//注意getElementByID里的ID是大写，并且id名要加引号<p>2.根据标签名获取元素<br>document.getElementByTagName(‘标签名’)</p><div>123</div>;<div>123</div>;<div>123</div>;//标签名也是要加引号。var box = document.getElementByTagName('div');//标签名获取元素得到一个对象集合的伪数组。想要拿到元素需要用for循环遍历//父元素节点.getElementByTagNamen()也可以用来获取父元素里面的某些子元素标签<p>3.H5新增获取元素方法(IE9以上支持)<br>（1）根据类名获取元素<br>document.getElementByClassName(‘类名’)</p><div class="box">123</div>;<div class="box">123</div>;var box = document.getElementByClassName('box');//获取的也是伪数组，不可以获取父元素节点下的子元素节点<p>（2）根据选择器获取元素<br>document.querySelector(‘选择器’)⭐</p><div class="box">123</div>;var box = document.querySelector('.box')//注意选择器必须写完整，比如类名选择器就写.box,id选择器就写#box//获取的是符合条件的第一个元素<p>document.querySelectorAll(‘选择器’)⭐</p><div class="box">123</div>;<div class="box">123</div>;<div class="box">123</div>;var boxs = document.querySelectorAll('.box');//获取所有符合条件的元素，返回的也是伪数组<p>4.获取特殊元素HTML，body<br>获取body<br>document.body//返回值是body对象</p><p>获取html<br>document.documentElement//返回值是html对象</p><p>三、事件⭐<br>事件就是指网页中的元素通过某些事件可以触发某个程序，比如点击按钮弹出警示框等</p><p>1.事件三要素<br>事件三要素是：事件源，事件类型，事件处理函数<br>（1）事件源 ：触发事件的元素（谁）；<br>（2）事件类型：触发事件的行为比如点击，移动鼠标等（什么事）；<br>（3）事件处理函数：触发事件后执行的代码（做什么）；</p><p>2.执行事件的步骤<br>（1）获取事件源（获取元素）<br>（2）注册事件（添加事件类型）<br>（3）添加事件处理函数（采取函数赋值的形式）</p><div>123</div>//获取事件源var div = document.qureySelector('div');//注册事件div.onclick = function (){    //添加事件处理函数    console.log('456')}//注意事件处理函数可以直接赋值，也可以将函数单独拿出来在事件后面写上函数名。div.onclick = fn;function fn (){    console.log('asda')}//注意这种写法函数名后面不能加（），否则会直接调用<p>4.常见的鼠标事件⭐<br>onclick 鼠标左击 onmouseover 鼠标经过<br>onmouseout 鼠标离开 onfocus 获取焦点<br>onblur 失去焦点 onmousemove 鼠标移动<br>onmouseup 鼠标弹起 onmousedown 鼠标按下</p><p>四、操作元素<br>javascript的DOM是用来操作页面内容和样式的。</p><p>1.获取和修改元素内容<br>元素.innerText</p><div>123</div>;    var div = document.querySelector('div');    div.innerText = 'asf';//注意T要大写<p>注意：innerText只能读取或者修改纯文本内容，不包含换行空格等格式信息。</p><p>元素.innerHTML（常用）</p><div>123</div>;    var div = document.querySelector('div');    div.innerHTML = 'sadfa';//HTML要全部大写<p>注意：innerHTML能够读取或者修改元素的内容，格式和html标签都可以，但是有兼容性问题。<br>注意：这两个获取和修改元素内容的方法只对双标签有用，单标签无法使用。</p><p>2.获取和修改元素属性<br>获取：元素名.属性名<br>修改：元素名.属性名 = ‘值’<br>例：<br>var input = document.querySelector(‘input’);<br>input.type = ‘text’;</p><p>特殊属性：disabled（禁用），checked（复选框选中），selectde（单选框选中），他们的值是true，false。<br>注意：修改属性值的时候值一定要加’’引号，值的书写规范和html一样。<br>表单元素的内容可以通过获取value值获取内容。<br>类名class是保留字获取属性写法不是元素名.class ，正确写法是 元素名.className</p><p>2.1标记变量（常用）<br>在练习京东密码输入框时用到了标记变量的用法。<br>标记变量就是设置一个变量来标记当前元素的状态，在每次改变元素属性或者样式的时候改变标记变量的值，通过判断标记变量的值来确定元素当前所处的状态。<br>注意：标记变量是程序员自己设置的不是固定的变量，通常使用flag作为变量名。</p><p>3.操作样式属性</p><p>（1）行内样式操作<br>行内样式操作创建和修改的元素样式是将样式通过行内样式写入结构中的，并且行内样式的权重高于内嵌式的样式。当修改的样式不是很多时使用。<br>（2）创建或者修改<br>元素名.style.样式名 = ’值‘；<br>例：<br>var var input = document.querySelector(‘input’);<br>input.style.color = ‘pink’;</p><p>注意：样式名是有两个以上单词或者中划线的将中划线去除并且从第二个单词开始每个单词首字母大写<br>并且右边的样式值也要用’’引号包含。<br>当有变量参与遵循字符串的拼接方式</p><p>（3）类名样式操作<br>类名样式操作，是通过修改或添加多个类名来实现样式的改变。<br>当需要修改多个元素的多个样式可以使用，在css中提前添加好相对应类名的样式<br>（4）添加或修改类名<br>input.className = ‘box ren’</p><p>注意：值需要用引号包含，书写类名规范遵循html书写规范，两个类名中间用空格分开<br>className会直接更改元素类名把之前的覆盖掉</p><p>第二天</p><p>一、排他思想<br>如果有一组元素，想给这一组元素绑定事件，事件触发后某个元素修改样式其他元素不变，再次触发除了事件触发元素样式改变其他元素样式不变。这时就需要使用排他思想来处理。</p><p>排他思想的核心是先干掉所有人，再单独设置。<br>1.事件触发后先将所有元素样式清除回复默认的样式<br>2.清除样式后再对需要改变样式的元素单独设置样式。<br>注意：顺序不能错</p><p>二、自定义属性<br>1.获取属性值<br>获取属性值之前的方法是 元素.属性名 这种方法只能获取元素本身自带的属性。<br>元素名.getAttribute(‘属性名’) 这种方法可以获取到元素内所用已有属性，通常用来获取自定义属性。</p><p>自定义属性是程序员自己给元素添加的属性，主要用途是用来区分和标记页面内多个相同元素，方便使用js来分别设置。</p><p>2.设置属性值<br>元素名.属性名 = ’值‘；用来设置元素自带的属性<br>元素名.setAttribute（’属性名‘，’值‘）；主要用来设置自定义属性</p><p>3.移除属性<br>元素名.removeAttribute（’属性名‘）；主要用来移除自定义属性</p><p>4.案例<br>案例中通过设置自定义属性和绑定事件的元素进行一一对应。</p><p>5.H5自定义属性（了解）<br>h5规定自定义属性名必须以data-开头并且赋值<br>h5新增元素名.dataset.属性名（获取的时候可以省略data-）；从ie11才开始支持</p><p>三、节点<br>节点：网页中所有的内容都是节点。<br>一般节点至少有一下三个基本属性：<br>nodeType：节点类型；<br>nodeName：节点名称；<br>nodeValue：节点值；<br>元素节点nodeType值为1<br>属性节点nodeType值为2<br>文本节点nodeType值为3（包含文字，空格，换行等）<br>可以将节点根据层级关系进行划分为父子，兄弟层级。</p><p>1.父级节点<br>节点名.parentNode  ：返回的是该元素最近的父级节点，注意是最近的父级节点</p><p>2.子节点<br>（1）所有子节点<br>父节点名.childrenNodes  ：这是标准写法，获取的是父节点下的所有节点集合的伪数组包括元素节点，属性节点，文本节点等，想要获取类里面的元素节点需要专门处理，一般不建议使用</p><p>（2）获取子元素节点（重点）<br>父节点名.children  ：这是非标准写法但是各个浏览器都支持，获取的是父节点下的所有子元素节点集合的位数组。</p><p>获取第一个子节点<br>父节点.firstChild  ：获取第一个子节点，找不到则返回null，是从所有子节点里查找</p><p>获取最后一个子节点<br>父节点.lastChild ：获取最后一个子节点，找不到则返回null，是从所有子节点里查找</p><p>获取第一个子元素节点<br>父节点.firstElementChild ：获取第一个子元素节点，找不到返回null</p><p>获取最后一个子元素节点<br>父节点.lastElementChild ：获取第一个子元素节点，找不到返回null</p><p>注意：最后两个有兼容性问题IE9以上才支持。</p><p>因为上面的方法有兼容性问题，lastChild又是从所有节点中获取，所以通过一下办法获取第一个和最后一个子元素节点<br>父节点.children[0]；第一个子元素<br>父节点.children[父节点.children.length - 1]；最后一个子元素。</p><p>3.兄弟节点<br>（1）下一个兄弟节点<br>节点名.nextSibling  ：返回当前节点的下个兄弟节点，没有返回null；</p><p>（2）上一个兄弟节点<br>节点名.previousSibling  ：返回当前节点的上个兄弟节点，没有返回null；</p><p>（3）下一个兄弟元素节点<br>节点名.nextElementSibling ：返回当前节点的下个兄弟元素节点，没有返回null</p><p>（4）上一个兄弟元素节点<br>节点名.previousElementSibling ：返回当前节点的下个兄弟元素节点，没有返回null</p><p>注意后面两个有兼容性问题，为了解决兼容性问题我们可以自己封装函数<br>   function getNextElementSibling(element) {<br>      var el = element;//接收输入的元素<br>      while (el = el.nextSibling) {//循环判断el.nextSibling是否是元素节点<br>        if (el.nodeType === 1) {<br>            return el;//是则输出<br>        }<br>      }<br>      return null;//不是则返回null<br>    }  </p><p>5.创建节点<br>document.createElement(‘元素名’) ：因为这是根据我们的需要创建的节点所以可以动态生成，也被称为动态创建元素节点。</p><p>6.添加节点<br>节点名.appendChild（元素名）：将元素添加到指定父级节点列表的末尾</p><p>节点名.insertBefore（元素名，指定节点）：将元素添加到父级节点内指定子节点的前面</p><p>给元素添加标签也可以使用.innerHTML通过字符串的拼接实现。<br>div.innerHTML = ‘<a><span></span></a>‘;//也可以用来添加元素</p><p>第三天</p><p>一、节点操作</p><p>1.删除节点<br>元素节点.removeChild（删除的元素）； 从父元素节点删除一个子节点返回的是删除的节点。</p><p>2.复制节点<br>元素节点.cloneNode（）复制该节点<br>注意：若小括号里的是空值或者false则是浅拷贝只复制元素本身不包含内容。<br>若小括号里的值是true则是深拷贝，将元素内的所有内容和元素本身一起复制。<br>复制节点并不会直接添加到页面需要通过添加元素的方法添加</p><p>3.创建元素的三种方法<br>（1）元素节点.innerHTML =  ‘要添加的内容’<br>将内容直接写入某个节点<br>（2）document.createElement（‘要创建的元素’）<br>创建的元素需要通过添加元素的方法才能添加到页面上<br>（3）document.write（‘要创建的元素’）<br>创建的元素默认是在body标签内从最后开始添加，但是当页面加载完成后调用会导致页面重绘只有write创建的元素。（很少使用）</p><p>4.对比innerHTML和createElement效率<br>通过cosole.time(‘名称’)   cosole.timeEnd(‘名称’) 来获取两个代码之间的代码运行时间判断运行效率。<br>注意：小括号内的名称需要一致。<br>或者通过再代码执行前打印 +new Date()，运行后再次打印来获取代码运行时间。<br>（1）使用innerHTML字符串拼接方式（因为字符串的不可变性，所以会极度占用栈内存导致运行效率低）<br>（2）使用createElement方式效率一般<br>（3）因为innerHTML是通过字符串的拼接来完成元素的创建和添加的，所以通过数组的方式存储需要创建的元素，然后转换成字符串通过innerHTML完成创建和添加效率会高很多。</p><p>二、DOM对象总结</p><p>1.创建<br>document.wrie<br>innerHTML<br>document.createElement</p><p>2.添加<br>appendChild<br>insertBefore</p><p>3.删除<br>removeChild</p><p>4.修改<br>主要通过dom元素的内容，属性，样式，值等来修改<br>1.修改元素属性：element.属性名 ，src，href，title等<br>2.修改双标签元素内容：innerHTML，innerText<br>3.修改表单元素内容：value，type，disabled，checked等<br>4.修改元素样式：style，className</p><p>5.获取<br>1.DOM提供的API方法：getElementById，getElementByTagName，不推荐使用<br>2.H5新增方法：querySelector，querySelectorAll ，建议使用<br>3.节点操作获取元素：父（parentNode），子（children），兄（previousElementSibling，nextElementSibling）建议使用</p><p>6.自定义属性<br>可以对元素添加属性和值，一般用来对自定义属性设置。<br>1.setAttribute:设置自定义属性<br>2.getAttribute:获取自定义属性值<br>3.removeAttribute:删除自定属性</p><p>三、事件高级</p><p>1.注册事件<br>传统方法</p><div>hi~</div>div.onclick = function(){}<p>特点：注册的事件具有唯一性，同一个元素同一个事件只能设置一个。多次设置以最后一个为准</p><p>监听注册</p><p>addEventListener()（IE9以后支持）</p><div>hi~</div>div.addEventListener('click',function(){})<p>特点：同一个元素同一个事件可以注册多个，会按照代码的先后顺序依次执行，可以接受三个参数<br>（1）type：事件类型字符串，比如‘click’，注意不要加on<br>（2）listener：事件处理函数，事件发生后会调用事件处理函数<br>（3）useCapture：可选参数，是一个布尔值，是否在捕获阶段执行事件处理函数，true为是，false为否</p><p>attacheEvent() （IE678支持）（了解）</p><div>hi~</div>div.attacheEvent('onclick',function(){})<p>可以接受两个参数<br>（1）eventNameWithOn:事件类型字符串，需要加on<br>（2）callback：事件处理函数</p><p>事件监听兼容性处理（了解）</p><p>2.删除事件</p><p>传统注册方式<br>元素.onclick = ‘’;或者null</p><p>监听注册方式<br>（1）元素 .removeEventListener(‘事件类型’，事件处理函数名)；<br>（2）元素.detachEvent（‘on事件类型’，事件处理函数名）；</p><p>删除事件兼容性解决方案（了解）</p><p>四、DOM事件流</p><p>在html中标签是互相嵌套的，可以当作是一个盒子里面放另一个盒子。<br>事件流指的就是事件在页面中接受事件的顺序。<br>当事件发生时会在元素节点之间按照一定顺序传播，这个传播的顺序就是DOM事件流</p><p>事件捕获：由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接受的过程。<br>当前目标阶段：事件传播到最具体的元素执行事件处理函数阶段。<br>事件冒泡：由最具体的元素开始逐级向上传播到DOM最顶层的节点位置的过程。</p><p>注意：<br>（1）js代码中只能执行捕获或者冒泡中的一个阶段<br>（2）传统注册事件方式和attachEvent只能得到冒泡阶段<br>（3）addEventListener第三个参数表示事件在捕获还是冒泡阶段调用事件处理函数，true表示捕获阶段，false表示冒泡阶段。<br>（4）有些事件是没有冒泡的，比如onblur，onfocus，onmouseenter，onmouseleave<br>（5）事件冒泡有时候我们并不需要，之后会设置阻止事件冒泡。</p><p>五、事件对象</p><p>在事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里，这个对象就是事件对象。</p><p>事件对象的使用</p><p>事件触发时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。所以需要在事件处理函数中申明一个形参来接收事件对象。<br>事件处理函数的第一个形参都是用来接受事件对象的，event就是事件对象，通常写成e或者evt都可以形参的名称实际上可以是任何名字只要符合命名规范。</p><p>事件对象的兼容性处理<br>在IE678中，浏览器不会给方法传递参数，如果需要的，需要到window.event中获取</p><script>var div = document.querySelectior('click',function(e){    e = e || window.event;    //当e为false则返回后面的值    //当e为true则直接返回e})</script><p>事件对象的属性和方法<br>1  e.target                  返回触发事件的对象（常用）<br>2.e.srcElemnt             返回触发事件的对象 非标准 ie678使用<br>3.e.type                      返回事件类型，如 click， mouseover 不带on<br>4.e.cancelBubble        阻止事件冒泡 非标准 ie678使用<br>5.e.returnValue           阻止默认事件（默认行为）非标准 ie678使用<br>6.e.stopPropagation()阻止事件冒泡 标准<br>7.e.preventDefault()   阻止默认事件 比如a链接跳转 标准<br>8.e.clientX/Y               鼠标在页面可视区域的坐标<br>9.e.pageX/Y               鼠标在页面的坐标<br>10.screepX/Y             鼠标在显示屏的坐标</p><p>e.target 和  this的区别<br>this指向的是事件绑定的元素或者函数的调用者。<br>e.target 指向的是事件的触发者<br>区别：当父级和子级盒子都绑定相同事件时子级盒子触发事件会冒泡到父级，父级同样也会触发事件<br>这是this指向的时父级盒子，而e.target指向的是触发事件的子级盒子。</p><p>阻止默认行为<br>e.preventDefault（）；标准写法<br>e.returnValue = false；低版本浏览器<br>return  false ； 也可以阻止默认行为没有兼容性问题。</p><p>阻止事件冒泡<br>e.stopPropagation();标准写法<br>window.event.cancelBubble = true;非标准，利用事件对象cancelBubble属性<br>兼容性处理</p><p>事件委托<br>原理<br>如果需要同时给多个元素设置相同的事件，可以给父级盒子设置事件通过target获取事件触发的元素来进行设置。<br>作用<br>值操作了一次DOM，提高了程序的性能，动态创建的子元素，也拥有事件。</p><p>例：</p><ul><li>点击，变色</li><li>点击，变色</li><li>点击，变色</li><li>点击，变色</li><li>点击，变色</li></ul><script>var ul = document.querySelector('ul');ul.addEventListener('click',function(e){e.target.style.backgroundColor = 'blue';})<p></script></p><p>六、常用鼠标按键<br>onclick                   鼠标点击<br>onmouseover        鼠标经过<br>onmouseout          鼠标离开<br>onfocus                 获取焦点<br>onblur                    失去焦点<br>onmousemove      鼠标移动<br>onmousedown      鼠标按下<br>onmouseup           鼠标弹起</p><p>鼠标事件对象<br>e.clientX               鼠标相对于浏览器可视窗口的X坐标<br>e.clientY               鼠标相对于浏览器可视窗口的坐标<br>e.pageX               鼠标相对于文档页面的X坐标，ie9以上支持（常用）<br>e.pageY               鼠标相对于文档页面的坐标，ie9以上支持（常用）<br>e.screenX            鼠标型对于电脑屏幕的X坐标<br>e.screenY            鼠标型对于电脑屏幕的Y坐标</p><p>通常通过page获取鼠标的位置</p><p>第四天</p><p>一、常用的键盘事件</p><p>键盘事件<br>onkeyup         键盘按键松开<br>onkeydown     键盘按下<br>onkeypress     键盘按下  但是不能识别功能键，比如ctrl shift 箭头等</p><p>注意：这三个事件的执行顺序是：keydown — keypress  —- keyup</p><p>键盘事件对象<br>keyCode        返回该键的ASCII码值</p><p>注意：keydown和keyup不区分大小写，可以返回所用按键<br>keypress不能识别功能键但是可以用来区分大小写，大写和小写返回的值不同。<br>在获取用户输入的最新内容时使用keyup，因为内容的输入分为：按键按下—-按下输入内容—-按键弹起，所以keyup可以获取用户输入的最新内容，而keydown只能获取上一次的输入内容。</p><p>二、BOM</p><p>什么时BOM<br>DOM时浏览器对象模型，它提供了独立于内容而于浏览器窗口进行交互的对象，核心对象时window。</p><p>DOM缺乏标准所以兼容性较差，在BOM中顶级对象时window，主要是浏览器窗口交互的对象</p><p>BOM构成<br>BOM比DOM更大，包含DOM</p><p>BOM中的顶级对象window<br>window作为浏览器的顶级对象，具有双重作用。<br>1.它是js访问浏览器窗口的一个接口<br>2.它是一个全局对象，定义在全局作用域中的变量和函数都会变成window对象的属性和方法。<br>在调用window的属性和方法时可以省略window.，之前的对话框都属于window对象的方法。<br>注意：window下的一个特殊属性window.name</p><p>window对象的常见事件<br>1.页面加载事件（重点）<br>（1）load<br>window.onload = function(){}<br>window.addEventListener(‘load’,function(){})</p><p>load是页面加载事件，当页面内容完全加载完成后会触发该事件（包含图片，js脚本文件，css文件等），有了load就可以将js代码写在任何地方。<br>注意：传统注册事件方式只能注册一次，之后注册的会被覆盖，建议使用监听事件方式</p><p>（2）DOMContentLoaded<br>window.addEventListener(‘DOMContentLoaded’,function(){})</p><p>ie9以上才支持<br>DOMContentLoaded是当DOM结构加载完成后就触发，优点时当页面内容很多的时候load需要等待内容全部加载完成之后才能触发会等待很长时间，DOMContentLoaded只需要等页面结构加载完成就可以触发了，此时用户就可以使用交互效果，体验更好。</p><p>2.调整窗口大小事件<br>resize<br>window.onresize = function(){}<br>window.addEventListener(‘resize’,function(){})</p><p>resize时窗口调整事件，当浏览器窗口发生变化就会触发。通常用来完成响应式布局。<br>window.innerWidth 当前窗口的宽度</p><p>3.定时器（重点）<br>setTimeout()一次性定时器（炸弹定时器）<br>window.setTimeout(function(){},1000)//(调用函数，延时事件单位毫秒)</p><p>注意：window可以省略，函数可以写匿名函数，函数名或者’函数名()’最后一种方法不推荐<br>延时时间可以省略默认是0，如果写必须是毫秒<br>定时器可以有很多，多个定时器有自己唯一的数字ID一般从1开始，通常我们会使用变量来接收这个ID数。<br>回调函数就是没有立即执行的函数，比如时间处理函数，定时器等都是回调函数</p><p>取消定时器<br>window.clearTimeout(timeoutID)</p><p>注意：小括号里的参数是定时器的ID数或者接收该ID值的变量</p><p>setInterval()循环定时器（闹钟定时器）<br>window.setInterval(function(){},1000)//(调用函数，间隔时间单位毫秒)</p><p>setInterval()可以重复调用一个函数，每个一段时间就会去调用一次。<br>注意：window可以省略，函数可以写匿名函数，函数名或者’函数名()’最后一种方法不推荐<br>延时时间可以省略默认是0，如果写必须是毫秒<br>定时器可以有很多，多个定时器有自己唯一的数字ID一般从1开始，通常我们会使用变量来接收这个ID数<br>第一次执行也是间隔时间后执行。<br>停止计时器<br>window.clearInterval(intervalID)</p><p>注意：小括号里的参数是定时器的ID数或者接收该ID值的变量</p><p>this指向问题<br>this的指向在函数定义的时候无法确定，只有在函数调用的时候才能确定指向，一般情况下this指向的始终是调用它的对象。<br>1.全局作用域或者普通函数中的this指向的都是window<br>2.方法调用中谁调用指向谁<br>3.定时器中指向window<br>4.构造函数中this指向构造函数的实例（创建的对象）</p><p>location对象<br>location属性用于获取或设置窗口的URL，并且可以用于解析URL。因为返回的是一个对象所以称为location对象。</p><p>URL<br>统一资源定位符是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器因该怎么处理它。<br>URL的一般语法格式为：<br>网络协议：// 主机（域名）/  路径 ？参数 # 片段<br>protocol://host[:port]/path/[?query]#fragment<br><a href="http://www.itcast.cn/index.html?name=andy&amp;age=18#link">http://www.itcast.cn/index.html?name=andy&amp;age=18#link</a></p><p>location对象属性<br>location.href                  获取或者设置整个URL（重点）<br>location.host                 返回主机（域名）<a href="http://www.baidu.com/">www.baidu.com</a><br>location.port                 返回端口号，如果没写返回空的字符串<br>location.pathname        返回路径<br>location.search             返回参数（重点）<br>location.hash                返回片段#后面内容常见于链接锚点</p><p>修改location.href的值可以实现跳转</p><p>通过表单域可以向另一个页面传递参数，传递的参数在URL中的location.search中。<br>参数在location.search中以键值对的形式储存，多个参数之间以&amp;分割。<br>获取search中的参数，需要先通过substr将？去除，再通过split(‘&amp;’)将每个参数分割成数组的形式，<br>最后再次使用split(‘=’)将每个参数里的参数名和值分割成数组。通过索引号获取相对应的数据。</p><p>location对象的常用方法<br>location.assign()        跟href一样可以跳转页面<br>location.replace()       替换当前页面，因为不记录历史所以不能后退页面<br>location.reload()         重新加载页面，相当于刷新。</p><p>navigator对象<br>navigator对象包含有关浏览器的信息，有很多属性，最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值。<br>判断用户使用哪个终端打开页面，实现跳转<br>if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {<br>    window.location.href = “”;     //手机<br> } else {<br>    window.location.href = “”;     //电脑<br> }</p><p>如果是手机则跳转到移动端页面，如果是电脑则跳转到pc端页面</p><p>history对象<br>history对象包含用户在浏览器窗口中访问过的URL<br>back()            可以用作后退功能<br>forward()        前进功能<br>go(参数)         前进和后退，参数如果是2则前进2个页面，如果是-2则后退个页面。<br>history对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。</p><p>三、JS执行机制</p><p>JS运行机制<br>js是单线程语言，同一时间只能做一件事。<br>单线程就意味着所有任务都需要排队，前一个任务结束后后一个任务才会执行。<br>当前一个任务长时间没有完成，后一个任务就要一直等，这样会导致js运行效率底下。</p><p>同步任务和异步任务<br>为了解决单线程的缺陷，利用多核CPU的计算能力，HTML5提出Web Worker标准，允许js脚本创建多个线程，但是子线程完全受主线程控制。于是JS中就出现了同步任务和异步任务</p><p>同步任务<br>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</p><p>异步任务<br>不进入主线程、而进入”任务队列”的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。<br>js异步是通过回调函数实现的。<br>异步任务有以下几种：<br>1.普通事件：click，resize等；<br>2.资源加载：如load，error等；<br>3.定时器：setInterval等；<br>异步任务的相关函数（回调函数）放入任务队列中。</p><p>JS执行机制<br>1.先执行栈中的同步任务。<br>2.异步任务（回调函数）放入任务队列。<br>3.当同步任务执行完后，系统就会依次读取任务队列中的异步任务，于是被读取的异步任务进入执行栈，开始执行。在主线程结束后会反复查询任务队列是否有需要执行的异步任务，这个动作被称为事件循环。</p><p>第五天<br>一、元素偏移量</p><p>offset<br>element.offsetParent         返回该元素最近带有定位的父级元素，如果没有则返回body<br>element.offsetTop              返回该元素相对最近带有定位父级元素的上偏移大小（没有单位）<br>element.offsetLeft              返回该元素相对最近带有定位父级元素的左偏移大小（没有单位）<br>element.offsetWidth           返沪该元素自身包括padding，border和内容的宽度（没有单位）<br>element.offsetHeight          返沪该元素自身包括padding，border和内容的高度（没有单位）</p><p>offset 和style的区别</p><p>offset<br>offset可以得到任意样式表中的样式值<br>offset系列获取的数值都是没有单位的<br>offsetWidth，offsetHeight包含padding，border和内容的宽高<br>offsetWidth等属性是只读属性，只能获取不能赋值</p><p>style<br>style 只能得到行内样式表中的样式值<br>style.width 获得的是带有单位的字符串<br>style.width 获得不包含padding和border 的值<br>style.width 是可读写属性，可以获取也可以赋值</p><p>元素可视区client系列<br>element.clientTop          返回元素上边框大小<br>element.clientLeft          返回元素左边框的大小<br>element.clientWidth       返回元素的宽度包括padding，返回的时数值<br>element.clientHeight     返回元素的高度包括padding，返回的时数值<br>注意：行内元素无法获取宽高</p><p>立即执行函数<br>(function(){})()或者(function(){}())<br>作用：主要时创建一个独立的作用域，避免命名的冲突，学习了闭包后常用来创建小闭包<br>注意：当使用的是无分号书写的代码立即执行函数前要加！或者，之类的进行分割。</p><p>淘宝flexible.js源码分析<br>一下三种情况都会触发load事件。<br>1.链接<br>2.刷新<br>3.前进后退<br>但是火狐有一个往返缓存的特性，这个缓存会将整个页面都保存，这时后退页面是不会触发load事件。此时就需要使用pageshow事件，pageshow是在load事件之后触发，并且根据事件对象中的persisted来判断是否是缓存中的页面触发的事件，是则返回true，否则返回false。注意pageshow需要给window绑定</p><p>元素滚动scroll系列<br>element.scrollTop                返回被卷区的上侧距离，返回值不带单位<br>element.scrollLeft                返回被卷区的左侧距离，返回值不带单位<br>element.scrollWidth             返回自身内容宽度，不含border和padding<br>element.scrollHeight            返回自身内容高度，不含border和padding</p><p>滚动条滚动事件<br>当页面滚动时会触发scroll事件。页面被卷区的距离是window.pageYOffset，window.pageXOffset（IE9以上支持）。通过window.scroll(x,y)让页面回到指定位置，注意里面的x，y必须写值，没有可以写0。</p><p>获取页面被卷去的距离兼容性写法<br>function getScroll() {<br>    return {<br>      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,<br>      top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0<br>    };<br> }<br>使用的时候  getScroll().left</p><p>mouseenter 和 mouseover 的区别<br>mouseenter 和 mouseover 都是鼠标经过触发。不同的是mouseenter经过子盒子不会触发，而mouseover经过子盒子时还会再触发。原因是因为mouseenter不会触发事件冒泡，和 mouseenter 相对应的鼠标离开 mouseleave 同样不会冒泡</p><p>动画函数的封装<br>核心原理：通过计时器让元素每过一段时间移动一段距离，从而达到模拟动画的效果。<br>function animate (box,target,callback){<br>    //为了方式多次点击产生多个定时器，每次点击时先清除定时器<br>    clearInerval(box.timer);<br>    //为了防止清除其他元素的动画效果，对元素对象添加timer属性<br>    box.timer = setInterval(function(){<br>        //判断是否到达指定位置<br>        if (box.offsetLeft == target) {<br>            //通过逻辑中断判断callback是否有传值<br>            callback &amp;&amp; callback();<br>           return<br>        }<br>        //为了达到缓动动画的效果，减少每次移动的距离<br>        //设置变量 distance 距离 保存每次移动距离<br>        var distance = (target - box.offsetLeft) / 10<br>       //上述公式结果为小数，无线接近于0，导致无法到达指定位置，所以需要取整<br>       //大于0向上取整，小于0向下取整<br>       distance = distance &gt; 0 ? Math.ceil(distance) : Math.floor(distance);<br>       //每过10毫秒，向右移动1px<br>       box.style.left = box.offsetLeft + 1 + ‘px’;<br>    },10);<br>}</p><p>第六天</p><p>轮播图案例<br>案例在E:\html\html\wab Api\day06\lesson006\005-轮播图案例\index.html<br>主要使用封装好的欢动动画函数做动画，用自定义属性将按钮和圆点相对应。<br>通过在所有图片后面添加第一张图，当移动到最后一张图点击下一张时瞬间拉回第一张此时不要做动画，之后再过渡到第二张达到无缝循环的效果。<br>最后通过节流阀，在动画开始时关闭阀门结束后打开，避免多次点击后动画过快的情况。</p><p>触摸事件<br>touchstart            手指触摸事件<br>touchmove          手指移动事件<br>touchend             手指离开事件</p><p>触摸事件对象<br>touch.event  触摸事件对象<br>touches                         正在触摸屏幕的所有手指<br>targetTouches               正在触摸当前元素上的所有手指（重点）<br>changedTouches           手指状态发生了改变的列表，从无到有，从有到无</p><p>targeTouches[0].pageX/Y  获取第一个手指在页面上的坐标<br>注意：手指移动过也会触发滚动屏幕所以需要阻止默认的屏幕滚动 e.preventDefault();</p><p>移动端轮播图案例<br>因为移动端的兼容性比PC端好，所以动画部分可以使用transtion过渡动画，通过transform ：translateX/Y 来移动元素。<br>移动端的轮播图因为用户是可以通过手机缓慢拖动图片的，如果是拖动的是第一张和最后一张图片会出现空白的地方。这样用户体验不好，为了实现无缝衔接在第一张图片前面加最后一张图片，在最后一张图片加第一张图片，当滑动到最后一张图片之后瞬间拉到第二张图片上之后再按顺序滑动。当滑动到第一张图片之后瞬间推到倒数第二张图片上。</p><p>classList属性<br>classList是H5新增的属性，IE10以上支持，用于元素类名的添，删，切换。<br>element.classList.add(‘类名’)            添加类名，在原来的基础上添加类名<br>element.classList.remove(‘类名’)      删除类名<br>element.classList.toggle(‘类名’)        切换类名，当元素有这个类名则删除这给类名，没有则添加<br>注意：这里的类名都不需要加.点</p><p>click延时解决方案<br>移动端click事件会有300ms的延时，原因是因为移动端双击屏幕会缩放页面。<br>1.禁用缩放。</p><meta name="viewport" content="user-scalable=no"><p>禁止用户缩放页面，同时去除了300ms的延时问题</p><p>2.封装函数<br>当用户可以缩放页面时，通过封装函数来解决延时问题。<br>手指点击时记录时间，手指离开后的时间减去点击的时间&lt;150ms并且没有移动则视为点击。<br>//封装tap，解决click 300ms 延时<br>function tap (obj, callback) {<br>        var isMove = false;<br>        var startTime = 0; // 记录触摸时候的时间变量<br>        obj.addEventListener(‘touchstart’, function (e) {<br>            startTime = Date.now(); // 记录触摸时间<br>        });<br>        obj.addEventListener(‘touchmove’, function (e) {<br>            isMove = true;  // 看看是否有滑动，有滑动算拖拽，不算点击<br>        });<br>        obj.addEventListener(‘touchend’, function (e) {<br>            if (!isMove &amp;&amp; (Date.now() - startTime) &lt; 150) {  // 如果手指触摸和离开时间小于150ms 算点击<br>                callback &amp;&amp; callback(); // 执行回调函数<br>            }<br>            isMove = false;  //  取反 重置<br>            startTime = 0;<br>        });<br>}<br>//调用<br>  tap(div, function(){   // 执行代码  });</p><p>3.fastclick插件<br>当有多个元素需要点击事件时，可以使用fast click插件解决<br>在GitHub官网上的lib文件中的fastclick，将文件中的代码复制粘贴，在自己的文件中引入。<br>最后在js文件中写入一下代码<br>if (‘addEventListener’ in document) {<br>    document.addEventListener(‘DOMContentLoaded’, function() {<br>        FastClick.attach(document.body);<br>    }, false);<br>}</p><p>之后正常书写代码就可以了。<br>GitHub官网地址： <a href="https://github.com/ftlabs/fastclick">https://github.com/ftlabs/fastclick</a></p><p>移动端常用开发插件</p><p>fast click<br>fast click插件，解决移动端click点击事件300ms延时问题</p><p>Swiper轮播图插件（重点）<br>中文官网地址： <a href="https://www.swiper.com.cn/">https://www.swiper.com.cn/</a><br>1.引入文件    2.根据规定语法使用<br>在官网中有详细的中文教程。</p><p>其他插件<br>superslide： <a href="http://www.superslide2.com/">http://www.superslide2.com/</a><br>iscroll： <a href="https://github.com/cubiq/iscroll">https://github.com/cubiq/iscroll</a></p><p>移动端视频插件zy.media.js</p><p>本地存储<br>本地存储就是将数据存储在用户浏览器中，设置，读取更方便，并且刷新页面数据也不会丢失。<br>容量较大，sessionStorage约5M、localStorage约20M，但是存储的数据只能是字符串。</p><p>window.sessionStorage<br>1.生命周期为关闭浏览器页面<br>2.在哦你一个页面下数据共享<br>3.以键值对的形式存储<br>保存数据：<br>sessionStorage.setItem(‘数据名’,’数据’)</p><p>删除数据：<br>sessionStorage.removeItem(‘数据名’)</p><p>获取数据：<br>sessionStorage.getItem(‘数据名’)</p><p>清空数据：<br>sessionStorage.clear()</p><p>window.localStorage</p><p>1.数据永久生效，除非手动删除<br>2.可以多个页面共享<br>3.以键值对形式存储<br>保存数据：<br>localStorage.setItem(‘数据名’,’数据’)</p><p>删除数据：<br>localStorage.removeItem(‘数据名’)</p><p>获取数据：<br>localStorage.getItem(‘数据名’)</p><p>清空数据：<br>localStorage.clear()</p><p>本地存储的序列化和反序列化<br>本地存储只能存储字符串，当需要存储数组或者对象时需要使用JSON.stringify()序列化方法将数组或者对象转换成字符串。之后再通过JSON.parse()反序列方法将本地存储的字符串数据转换成数组或者对象。<br>var arr = [1,2,3,4,5];<br>localStorage.setItem(‘数据名’,JSON.stringify(arr));<br>var res = localStorage.getItem(‘数据名’);<br>JSON.parse(res);</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高级</title>
    <link href="/2021/02/09/JS%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/02/09/JS%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>第一天</p><p>面向过程与面向对象</p><p>面向过程<br>面向过程就是分析出解决问题的步骤，然后按照步骤一步一步处理，使用的时候依次调用即可。</p><p>面向对象<br>面向对象就是将事件分为一个一个对象，然后由各个对象分工合作处理事件。</p><p>对比<br>面向过程 面向对象<br>面向过程比面向对象性能更高，适合与硬件练习紧密的东西 易维护，易复用，易扩展，由于面向对象由封装、继承、多态性的特性，可以设计除低耦合的系统，通常在多人合作中使用。<br>不易维护，不易复用，不易扩展 性能比面向过程低</p><p>对象与类</p><p>对象<br>对象是由无序的多个属性和方法组成的集合。</p><p>创建对象<br>字面量创建<br>var obj = {}</p><p>构造函数创建<br>function Student (name,age) {<br>    this.name = name;<br>    this.age = age;<br>}<br>var obg = new Student(‘小红’,12)</p><p>类<br>在es6中新增了类的概念，可以使用class关键字申明一个类，然后用类创建多个实例化对象。<br>类是抽象了对象的公共部分，泛指一大类，而对象特指某一个，通过实例化来创建对象。</p><p>类的创建和添加属性、方法<br>//类名后面直接跟{}大括号，不需要（）小括号<br>class Student {<br>    //将共有的属性放到constructor里面<br>    constructor(name,age,height){<br>        this.name = name;<br>        this.age = age;<br>        this.height = height;<br>    }<br>    //注意方法和方法之间不需要加，逗号<br>   //注意在类中帮我们省略了function声明函数，直接写（）{}就可以<br>   sey(){<br>       console.log(‘hello’)<br>   }<br>}<br>var xm = new Student(‘小明’,12,150);<br>xm.sey();</p><p>注意：1.通过class关键字创建的类，类名首字母大写。<br>2.类里面有一个constructor函数，可以接收传过来的参数，同时返回实例对象<br>3.constructor函数只要new生成实例对象就会自动调用，就算我们不写也会自动生成这个函数。<br>4.多个函数方法之间不需要逗号分割<br>5.生成实例时必须要加new<br>6.语法规范，创建类 类名后不需要小括号，方法构造函数不需要加function。</p><p>类的继承</p><p>语法<br>class Father {<br>    constructor(x,y){<br>        this.x = x;<br>        this.y = y<br>    }<br>}<br>class Son extends Father{<br>    constructor(x,y){<br>        super(x,y)<br>    }<br>}</p><p>注意：<br>1.继承中，子类要想使用this必须先调用super()之后才能使用this属性<br>2.如果子类创建的实例化对象需要调用方法或者属性，先看子类里有没有，有则调用子类的方法或者属性，没有则到父类中查找。<br>3.注意this指向问题<br>4.在ES6中类没有变量提升，所以必须先定义类，才能通过实例化对象。</p><p>面向对象版tab栏切换<br>E:\html\html\JS高级\day01\lesson001(1)\009-tab栏选项卡案例\index.html</p><p>第二天</p><p>一、构造函数和原型</p><p>1.对象的三种创建方式</p><p>（1）字面量创建<br>var obj = {}</p><p>（2）new关键字<br>var obj = new Object()</p><p>（3）构造函数<br>function Obj (name,age){<br>    this.name =name;<br>    this.age = age;<br>}<br>var obj = new Obj(‘小明’,12)</p><p>2.构造函数的成员</p><p>（1）实例成员<br>实例成员就是构造函数通过this添加的属性或者方法。实例成员只能通过实例化的对象进行访问。<br>//构造函数中的this指向的是创建的实例对象，函数和对象都属于复杂数据类型<br>//复杂数据类型变量或者函数名保存的是复杂数据类型的地址值<br>//因为new关键字创建了新的内存空间，this将参数传给了实例对象所以构造函数无法获取<br>//实例对象中的属性和方法，也就无法获取实例成员<br>function Obj (name,age){<br>    this.name = name;<br>    this.age = age;<br>    this.sey = function(){<br>        console.log(‘hello’)<br>    }<br>}<br>var xm = new Obj(‘小明’,12);<br>console.log(xm.name)//结果为  小明<br>console.log(Obj.name)//结果为 undefined</p><p>（2）静态成员<br>静态成员是对构造函数本身进行添加的属性或者方法。静态成员只能通过构造函数进行访问，构造函数创建的实例对象无法访问。<br>//因为构造函数创建的实例对象和构造函数本身不是一个内存空间<br>//所以给构造函数单独添加的属性和方法跟和实例对象不是在一个内存空间<br>//实例对象就无法获取静态成员。<br>function Obj (name,age){<br>    this.name = name;<br>    this.age = age;<br>    this.sey = function(){<br>        console.log(‘hello’)<br>    }<br>}<br>Obj.sex = ‘男’;<br>var xm = new Obj(‘小明’,12);<br>console.log(xm.sex)//结果为  undefined<br>console.log(Obj.sex)//结果为 男</p><p>3.构造函数的问题<br>构造函数在创建实例对象的时候，会有这样一个问题。因为每次调用构造函数new关键字就会创建一个新的内存空间，而对象中的方法也是复杂数据类型也需要单独的内存空间存放。当创建多个实例对象的时候就会出现资源浪费的情况。</p><p>4.构造函数原型prototype<br>js规定每个构造函数都有prototype原型对象，原型对象是所有构造函数创建出的实例对象所共享的。<br>可以将那些不变或者相同的方法直接定义在prototype上，这样所有实例对象都能够使用这些方法。</p><p>5.对象原型<br>所有对象都有一个属性__proto__指向的是构造函数的prototype原型对象。实例对象之所以能够使用prototype里的方法和属性就是因为__proto__的存在。</p><p>6.constructor构造函数<br>所有对象原型__proto__和构造函数的原型对象prototype都有一个属性就是constructor属性，constructor指向的是构造函数本身，主要用于记录该实例对象和原型对象是哪个构造函数的。</p><p>一般情况下，对象的方法都在构造函数的原型对象中设置，如果有多个方法则可以给原型对象进行赋值。但是这样会覆盖掉constructor属性，所以我们需要手动添加constructor属性重新手动设置指向构造函数本身。</p><p>7.原型链<br>因为每个对象都有proto属性，指向构造函数的原型对象，原型对象也有proto属性，这样一层一层的往上叫做原型链。</p><p>8.原型对象和构造函数实例对象的关系<br>（1）构造函数的prototype属性指向了原型对象。<br>（2）实例对象的proto对象原型属性指向了原型对象。<br>（3）原型对象的constructor属性指向了构造函数，实例对象的原型proto里面的constructor也指向了构造函数。</p><p>9.原型链和成员的查找机制<br>当访问一个对象的属性或者方法时，先从自身查找是否有该属性或者方法。如果有则访问自身的，如果没有则查找它的原型对象。有则访问没有则继续向上。如果都没有则返回null。</p><p>10.原型对象中的this指向问题<br>构造函数中的this和原型对象中的this都指向构造出来的原型对象。</p><p>11.通过原型为数组扩展内置方法<br>Array.prototype.sum = function (){<br>    var sum = 0;<br>    for (var i = 0 ; i &lt; this.length ; i++){<br>        sum += this[i];<br>    }<br>    return sum;<br>}</p><p>二、继承</p><p>1.call()<br>call()时调用函数时可以修改this指向，小括号里的第一个参数是this的指向，后面的参数是对应函数形参的实参。使用逗号分割。<br>function fn (x,y){<br>    console.log(this);<br>    console.log(x + y)<br>}<br>fn.call([],1,2);//调用函数并且修改this指向，将this指向[]空数组。</p><p>2.子构造函数继承父构造函数<br>使用call方法调用父构造函数并修改this指向。<br>function Father (name,age){<br>    this.name = name;<br>    this.age = age;<br>}<br>function Son (name,age,height) {<br>    //使用call方法调用父构造函数并将this指向Son构建的实例对像<br>    Father.call(this,name,age);<br>    this.height = height;<br>}</p><p>3.利用原型对象继承方法<br>利用原型对象的共享方法来继承父构造函数的方法<br>function Father (name,age){<br>    this.name = name;<br>    this.age = age;<br>};<br>Father.prototype.sey = function(){<br>    console.log(‘hello’)<br>}<br>function Son (name,age,height) {<br>    //使用call方法调用父构造函数并将this指向Son构建的实例对像<br>    Father.call(this,name,age);<br>    this.height = height;<br>}<br>//将父构造函数的原型对象赋值给子构造函数的原型对象<br>//这样子构造函数创建的实例对象也能够使用父构造函数的方法<br>Son.prototype = new Father();<br>//但是这样赋值会出现原型对象的constructor属性丢失，需要手动添加指向子构造函数<br>Son.prototype.constructor = Son;</p><p>三、ES5新增方法</p><p>1.数组方法</p><p>forEach遍历数组<br>var arr = [1,2,3,4]<br>arr.forEach(function(value,index,arr){<br>    //参数1是遍历数组的每个数组元素相当于arr[i]<br>    //参数2是元素的索引值<br>    //参数3是数组本身<br>})</p><p>filter过滤数组<br>var arr = [1,2,3,4]<br>var newArr = arr.filter(function(value,index,arr){<br>    //筛选符合条件的元素，返回的是符合条件的元素组成的数组<br>    retur value &lt; 3;<br>})</p><p>some判断数组中是否有符合条件的元素<br>var arr = [1,2,3,4]<br>arr.some(function(value,index,arr){<br>    //判断数组中是否有符合条件的元素，返回的是布尔值<br>    return value &gt;= 4<br>})</p><p>every判断数组中元素是否都符合条件<br>var arr = [1,2,3,4]<br>arr.every(function(value,index,arr){<br>    //判断数组中的元素是否都符合条件，返回的是布尔值<br>    return value &gt; 10;<br>})</p><p>注意：</p><ol><li>forEach 和 filter 都会遍历完整个数组，return不会终止此循环。</li><li>some 和 every 不一定会遍历完数组，使用 some 当有元素符合则终止循环，使用 every 当有元素不符合则终止循环。</li></ol><p>2.字符串方法</p><p>trim去除字符串两端的空格<br>var str = ‘     abc     ‘<br>//去除字符串两端的空格<br>var str1 = str.trim()</p><p>3.对象方法</p><p>Object.keys(对象)获取对象的属性名<br>var obj = {<br>    name : ‘小明’,<br>    age : 12,<br>    height : 140<br>}<br>//获取对象里所有的属性名，返回值是一个数组。<br>var res = Object.keys(obj) </p><p>Object.definePropety 修改或新增对象的属性名<br>var obj = {<br>    name : ‘小明’,<br>    age : 12,<br>    height : 140<br>}<br>Object.definePropety(对象,修改或者新增属性名,{<br>    value:修改或者新增属性的值<br>    //属性的特性<br>    writable:true/false,//是否能够修改这个属性值，true是，false不可以<br>   enumerable:true/false,//是否允许遍历这个属性，true是，false不可以<br>   configurable:true/false,//是否允许删除或者修改特性，true是，false不可以<br>})</p><p>第三天</p><p>一、改变函数的this指向</p><p>1.call方法<br>使用call()方法调用函数，可以修改函数this的指向<br>function fn (str){<br>    console.log(this)<br>    console.log(str)<br>}<br>//第一个参数是函数中this的指向<br>fn.call({},123)</p><p>2.apply方法<br>使用apply()方法调用函数也可以改变函数this指向<br>function fn (str,num){<br>    console.log(this)<br>    console.log(str,num)<br>}<br>//第一个参数是函数中this的指向<br>fn.apply({},[‘小明 ‘,123]])</p><p>注意：与call方法不同的是apply方法第一个参数后面的实参是以数组的形式书写的，但是传递参数的方式还是一一对应的。</p><p>3.bind方法<br>使用bind方式不会调用函数，但是能改变函数this的指向返回的是一个新的函数。<br>function fn (str,num){<br>    console.log(this)<br>    console.log(str,num)<br>}<br>//第一个参数是函数中this的指向<br>var fun = fn.bind({},[‘小明 ‘,123]])<br>fun()//注意bind可以预设参数，预设之后可以直接调用函数不用传参，就算传参也不能修改</p><p>4.call、apply、bind相同点和不同点<br>相同点：都可以修改this指向</p><p>不同点：<br>call 和 apply 都会调用函数，bind不会调用函数会生成新的函数，并且可以预设参数<br>call 和 bind 传递参数都是以逗号隔开，而apply是数组的形式</p><p>应用场景：<br>call 常用于构造函数的继承<br>apply常与数组搭配使用<br>bind 常用于回调函数不调用函数改变this指向</p><p>二、严格模式</p><p>1.开启严格模式</p><p>为脚本开启严格模式</p><script>//当前script标签开启严格模式"use strict"</script><p>为函数开启严格模式<br>function fn (){<br>    //为函数开启严格模式<br>    “use strict”<br>}</p><p>2.严格模式中的变化<br>（1）严格模式中变量未声明不能使用，也不不能直接赋值<br>（2）严格模式中this默认是undefined<br>（3）严格模式中构造函数调用必须加new关键字<br>（4）严格模式中函数的参数不能重名</p><p>三、高阶函数</p><p>高阶函数对其他函数进行操作的函数，它接收的参数为函数或者返回的值是函数。这种函数称之为高阶函数。<br>例：<br>function fn (fun){<br>    fun()<br>}<br>function fun (){<br>    console.log(123)<br>}<br>//传入的参数是函数</p><p>function fn (){<br>   return function (){<br>    console.log(123)<br>    }<br>}<br>//返回的值是函数</p><p>四、闭包</p><p>闭包的定义：闭包是指内部函数访问外部函数声明的变量的结构称为闭包。<br>例：<br>function fu (){<br>    var num = 10;<br>    function (){<br>        console.log(num + 10)<br>    }<br>}</p><p>闭包的作用<br>1.闭包可以延申了变量的使用范围<br>2.实现了数据的封装<br>3.实现了数据的缓存（函数的柯里化）</p><p>闭包的缺点<br>1.闭包会是函数的变量都保存在内存中加大内存消耗（空间换时间）<br>2.容器容易引发内存泄漏（没有及时清理）</p><p>注意：闭包之所以能够保存函数变量，是因为在js的GC（垃圾清理机制）中会定期检查找出清理垃圾，当变量不再被引用时会进行清除释放内存。</p><p>闭包的应用<br>通过闭包获取for循环中的i变量<br>for (var i = 0; i &lt;10; i++){<br>    !(function(i){<br>    div.onclick = function(i){<br>        console.log(i)<br>    }<br>    })(i)<br>}<br>//通过立即执行函数创造一个小闭包，在将for循环中的i通过实参传递给内部的事件处理函数</p><p>五、递归</p><p>递归函数的定义：如果一个函数在内部调用自身，那么这个函数就是递归函数。<br>注意：递归函数的作用和for循环效果一样，由于递归容易引发‘栈溢出’错误，所以必须要加退出条件return。</p><p>递归函数的应用<br>获取树状数据<br>var data = [{ id: 1,<br>            name: ‘家电’,<br>            goods: [{ id: 11,<br>                    gname: ‘冰箱’,<br>                    goods: [{ id: 111,<br>                            gname: ‘海尔’ },<br>                            { id: 112,<br>                             gname: ‘美的’ }, ] },<br>            { id: 12,<br>             gname: ‘洗衣机’ }] },<br>           { id: 2,<br>            name: ‘服饰’ }];<br>function deepData (arr,id){<br>    //申明变量保存查询结果<br>    var res = null;<br>    //遍历数组<br>    arr.forEach(function(itme){<br>        //判断是否符合条件<br>    if (itme.id == id){<br>        //符合则保存结果<br>        res = itme;<br>        //因为forEach不会中断循环所以要判断是否已经找到数据，并判断这个数据是否有goods属性<br>    } else if (res == null &amp;&amp; itme.goods){<br>        //没有找到数据则再调用函数进入深层寻找<br>       res = deepData(itme,id);<br>    }<br>    //输出结果<br>    return res<br>    })<br>}<br>deepData(data,11)</p><p>第四天</p><p>正则表达式<br>正则表达式是用于匹配字符串组合的模式，再js中正则表达式也是对象。</p><p>正则表达式的特点<br>灵活性、逻辑性和功能性非常强，可以迅速地用极简单的方式达到字符串的复杂控制。</p><p>正则表达式的组成<br>正则表达式由简单字符构成或者字符与特殊字符的组合。<br>/abc/</p><p>边界符 ^  $<br>/^abc/<br>//以abc字符串开头<br>/abc$/<br>//以abc字符结尾<br>/^abc$/<br>//精准匹配，必须是abc，精确匹配字符数量和类型都需要符合</p><p>字符集[]<br>/[abcd]/<br>//表示字符中出现中括号中的任意一个字符即可，[]只能匹配一个字符<br>/^[abcd]/<br>//表示字符以中括号中的任意一个字符开头<br>/[abc]$/<br>//表示字符以中括号中的任意一个字符结尾<br>/^[abc]$/<br>//表示字符只能是中括号中任意一个字符<br>/^[0-9]$/<br>//表示0-9中任意个数字<br>/^[^abc]$/<br>//表示除了abc以外任何一个字符   [^] 取反字符，除了中括号里面的任意一个字符</p><p>量词符<br>/^abc*$/<br>//表示ab后面的c可以出现0次或者更多次 * ==（&gt;=0）<br>/^abc+$/<br>//表示ab后面的c可以出现1次或者更多次  + ==（&gt;=1）<br>/^abc?$/<br>//表示ab后面的c可以出现1次或者0次  ? ==（0 || 1）<br>/^abc{3}$/<br>//表示ab后面的c必须出现3次    {3} == 3<br>/^abc{3,}$/<br>//表示ab后面的可以出现3次或以上    {3,} ==（&gt;=3）<br>/^abc{3,4})$/<br>//表示ab后面的可以出现3次到4次    {3,4} ==（&gt;=3 &amp;&amp; &lt;= 4）</p><p>其他特殊字符<br>/^(abc|qwe)$/<br>//表示abc或者qwe    | == 或<br>/./<br>//  . 点表示除了换行符以外的所有字符<br>/./<br>// . 表示点</p><p>括号总结<br>1.小括号表示整体，优先执行<br>2.中括号表示字符集和，匹配中括号中的任意一个字符<br>3.大括号表示两次符，里面表示重复几次</p><p>预定义类<br>\d   ：匹配0-9之间任意一个数字，相当于 [0-9]<br>\D  ：匹配除了数字以外的所有字符串，相当于[^0-9]<br>\w  ：匹配所有字母，数字和下划线，相当于[a-zA-Z0-9_]<br>\W ：匹配除了字母，数字和下划线以外的任意一个字符，相当于[^a-zA-Z0-9_]<br>\s  ：匹配空格（空格，换行符，制表符等），相当于[\t\r\n\v\f]<br>\S ：匹配非空格，相当于[^\t\r\n\v\f]</p><p>检查是否符合正则test<br>test()方法用来判断字符串是否符合正则表达式，符合返回true，否则返回false<br>var str = /^abc$/;<br>str.test(‘abc’)//true</p><p>正则替换replace<br>replace()方法用来替换字符串中的字符。<br>let str = ‘abcdaefag’;<br>str.replace(‘a’,’你好’)//将str中第一个‘a’替换为‘你好’</p><p>replace()方法中第一个参数可以是正则表达式<br>let str = ‘abcdaefagA’;<br>str.replace(/a/,’你好’)//将str中第一个‘a’替换为‘你好’<br>str.replace(/a/g,’你好’)//将str中所有‘a’替换为‘你好’<br>str.replace(/a/i,’你好’)//将str中第一个‘a’替换为‘你好’，不区分大小写<br>str.replace(/a/gi,’你好’)//将str中所有‘a’替换为‘你好’，不区分大小写</p><p>注意：筛选字符串中需要替换的字符时不能使用精确匹配</p><p>正则匹配exec返回的是一个数组<br>let str = ‘asdfasdfdfadsfadsfads’;<br>let reg = /a/;<br>reg.exec(str);//匹配str字符串中的a，返回的是一个数组，每次只能匹配一个</p><p>第五天</p><p>Es6概念<br>6指的是从ES2015开始之后的所有版本，统称为ES6</p><p>ES6新增语法</p><p>块级作用域<br>在ES6中除了对象的大括号以外的所有{}内都是块级作用域。</p><p>新增变量声明★★★</p><p>let<br>let num = 10;</p><p>注意：使用let关键字声明的变量才具有块级作用域，使用var关键字是没有的<br>特性：<br>（1）let关键字申明的变量只在当前块级作用域和子块级作用域内有效<br>（2）let关键字声明的变量不存在变量提升，必须先声明再使用。<br>（3）存在‘暂存死区’，在全局作用域中声明一个变量，之后在块级作用域内声明同一个变量，此时在块级作用域中声明变量之前无法访问该变量。<br>（4）let关键字声明的变量不会自动挂载到window上。<br>（5）let关键字声明的变量同一作用域下变量名不能重复。</p><p>作用：<br>（1）防止循环变量变成全局变量，通过var声明的循环变量在循环体外也是可以访问的。<br>（2）和闭包一样可以保存循环的变量值。</p><p>const<br>const num = 10;</p><p>特性：<br>（1）const关键字声明变量必须使用用初始化，声明同时赋值。<br>（2）const关键字声明的变量具有不可变性，值为基础数据类型时不可修改，值为复杂数据类型时，可以修改复杂数据类型的内容，但是不能再次赋值为新的复杂数据类型。<br>（3）const关键字申明的变量只在当前块级作用域和子块级作用域内有效<br>（4）const关键字声明的变量不存在变量提升，必须先声明再使用。<br>（5）存在‘暂存死区’，在全局作用域中声明一个变量，之后在块级作用域内声明同一个变量，此时在块级作用域中声明变量之前无法访问该变量。<br>（6）const关键字声明的变量不会自动挂载到window上。<br>（7）const关键字声明的变量同一作用域下变量名不能重复。</p><p>解构赋值★★★</p><p>数组解构<br>let arr = [1,2,3,4,5];<br>let [a,b,c,d,e] = arr;<br>// a = 1 , b = 2, c = 3, d = 4, e = 5</p><p>数组结构会将数组里的元素按照顺序赋值给左边中括号中的变量。当变量多过元素后面的变量的值为undefined。如果不想获取某个元素，则使用逗号跳过该元素。<br>let arr = [1,2,3,4,5];<br>let [a,,b,c,d,e] = arr;<br>// a = 1 , b = 3, c = 4, d = 5, e = undefined</p><p>对象属性的解构<br>let obj = {<br>    a:1,<br>    b:2,<br>    c:3<br>}<br>let {a,b,c} = obj;<br>//a = 1, b =2 , c = 3;</p><p>对象结构，左边的大括号中需要写入对应属性名的变量名才能获取对应的属性值，如果没有对应变量名的属性则值为undefined。如果想让变量命名和属性名不一致，则需要以此格式书写    属性名：变量名,也可以使用此格式获取对象中的复杂数据类型。<br>let obj = {<br>    a:1,<br>    b:2,<br>    c:3<br>}<br>let {a:num,b,c} = obj;<br>//num = 1, b =2 , c = 3;</p><p>箭头函数★★★<br>ES6中新增定义函数的方式<br>() =&gt; {} //小括号表示参数，大括号表示函数体</p><p>特性：<br>（1）当函数只有一行代码并且就是返回值时可以省略大括号<br>（2）当函数只接收一个参数时可以省略下括号<br>（3）箭头函数中没有this指向，箭头函数中的this指向的是函数所在作用域的this指向。（重点）<br>（4）箭头函数不能使用 arguments 这个内置对象。</p><p>剩余参数<br>当函数需要接收多个变量时，可以通过 …变量名接收剩余参数或者全部参数，变量为一个数组<br>function fn (a,b,…c){<br>    console.log(a,b,c)// 1 2 [3,4,5,6,7]<br>}<br>fn (1,2,3,4,5,6,7)</p><p>剩余参数通常和结构配合使用<br>let arr = [1,2,3,4,5];<br>let [a,b,…c] = arr;<br>//a = 1 , b = 2 , c = [3,4,5]</p><p>ES6的内置对象扩展</p><p>Array（数组）的扩展方法★★★</p><p>扩展运算符<br>扩展运算符可以将数组和对象转化为用逗号分割的参数序列。<br>let arr = [1,2,3,4];<br>…arr // 1,2,3</p><p>扩展运算符可以用作数组的合并<br>let arr1 = [1,2,3];<br>let arr2 = [4,5,6];<br>let arr3 = […arr1,…arr2]</p><p>可以将伪数组或者类数组转换成正真的数组</p><p>Array.from() 方法<br>可以将伪数组或者类数组转换成正真的数组，该方法还可以接收第二个参数用来遍历修改数组<br>let arrayLike = { ‘0’: ‘a’,<br>                ‘1’: ‘b’,<br>                ‘2’: ‘c’,<br>                length: 3 };<br>let arr2 = Array.from(arrayLike,function(itme,index,arr){<br>    itme += 1<br>}); // [‘a1’, ‘b1’, ‘c1’]</p><p>find() 方法<br>find方法时找出数组中第一个符合条件的元素，有则返回该元素，没有则返回undefined。<br>let arr = [1,2,3,4];<br>arr.find(itme =&gt; itme &gt; 2) //返回 3</p><p>findIdex() 方法<br>findIdex() 方法是找出数组中第一个符合条件的元素，返回的是该元素的索引号，没有则返回-1<br>let arr = [1,2,3,4];<br>arr.findIdex(itme =&gt; itme &gt; 2) //返回 2</p><p>includes() 方法<br>includes() 方法是查询该数组是否包含给定的值。返回的是布尔值<br>let arr = [1,2,3,4];<br>arr.includes(2) //返回 true</p><p>String 的扩展方法</p><p>模板字符串★★★<br>ES6中新增的创建字符串的方式，使用反引号定义<br>let str = <code>abcd</code></p><p>在模板字符串中可以添加变量和任何表达式<br>let num = 10;<br>let str = <code>abdc$&#123;num&#125;asdfa</code><br>//大括号中可以是变量或者任何表达式</p><p>在模板字符串中可以换行<br>let str = <code>ab cd</code></p><p>starsWith() 和  endsWith() 方法<br>startsWith()：表示参数字符串是否以小括号内字符串开头，返回布尔值<br>endsWith()：表示参数字符串是否以小括号内字符串结尾，返回布尔值</p><p>repeat() 方法<br>repeat() 方法表示将源字符串重复几次。<br>let str = <code>abcd</code>;<br>str.repeat(10)//该字符串重复10次</p><p>Set数据结构★★<br>ES6提供了新的Set数据结构，它类似数组，但是成员的值都具有唯一性，不会出现重复的情况。</p><p>创建Set数据<br>let  se = new Set([1,2,3]);//小括号内可以为空，传参必须为数组。</p><p>添加元素<br>let  se = new Set([1,2,3]);<br>se.add(4);//每次只能添加一个成员,返回的是Set数据本身</p><p>删除元素<br>let  se = new Set([1,2,3]);<br>se.delete(2);//返回的是布尔值，表示是否删除成功</p><p>查询元素<br>let  se = new Set([1,2,3]);<br>se.has(3);//表示是否有这个数字，返回的是布尔值</p><p>清除所有<br>let  se = new Set([1,2,3]);<br>se.clear();//清除所有成员</p><p>遍历<br>Set数据和数组一样有forEach方法可以遍历Set数据。</p><p>for …  of 遍历<br>for  of 可以遍历数组，字符串，Set数据。<br>let arr = [1,2,34,5];<br>for (let itme of arr){<br>    console.log(itme)// 1 2 34 5<br>}</p><p>使用for  of 不能直接遍历对象需要进行处理一下<br>let obj = {<br>             a: 1,<br>             b: 2,<br>             c: 3<br>         }<br>         for (let itme of Object.keys(obj)) {<br>             console.log(itme);<br>             console.log(obj[itme]);<br>         }</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础</title>
    <link href="/2021/02/09/JS%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/02/09/JS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>计算机语言分为机器语言（0，1），汇编语言（简单的英语单词），高级语言（相对与低级语言又跟多的词汇更符合人类语言）</p><ul><li><p>翻译器:使用汇编语言或者高级语言编写的代码计算机无法识别需要翻译器进行翻译后在执行。</p></li><li><p>编程语言:编程语言有很强的逻辑性和行为能力，是主动的</p></li><li><p>标记语言:没有什么逻辑，一般是由系统读取的，是被动的<br>计算机由软件和硬件组成:</p></li><li><p>软件:系统软件（winds系统，linuk系统等），应用软件（qq，浏览器等）</p></li><li><p>硬件:输入设备（键盘，鼠标等） 输出设备（显示器，音响等）CPU 主板 内存 硬盘。<br>计算机中数据都是以01的形式储存的。<br>储存单位:</p></li><li><p>bit       （1bit储存一个0或1）</p></li><li><p>Byte      （1B=8b）</p></li><li><p>KB        （1KB=1024B）</p></li><li><p>MB        （1MB=1024KB）</p></li><li><p>GB        （1GB=1024MB）</p></li><li><p>TB        （1TB=1024GB）<br>js属于脚本语言，脚本语言不需要编译，运行中由js解释器进行翻译并执行。并且是逐行翻译执行。<br>js的作用:</p></li><li><p>表单动态校验（密码强度检测）  （ JS 产生最初的目的 ）</p></li><li><p>网页特效</p></li><li><p>服务端开发(Node.js)</p></li><li><p>桌面程序(Electron)</p></li><li><p>App(Cordova) </p></li><li><p>控制硬件-物联网(Ruff)</p></li><li><p>游戏开发(cocos2d-js)</p><p>JavaScript的组成:ECMASCript（js语法），DOM（页面对象模型），BOM（浏览器对象模型）<br>js书写分为:行内式，内嵌式，外联式和css相同。<br>注意:js引入写法为<script src="my.js"></script><br>js的注释:单行//（快捷键ctrl+/） 多行 /<em>内容</em>/（快捷键alt+shift+a，修改为shift+ctrl+/）</p></li></ul><h3 id="JavaScript输入输出语句"><a href="#JavaScript输入输出语句" class="headerlink" title="JavaScript输入输出语句"></a>JavaScript输入输出语句</h3><p>alert（内容）:浏览器弹出警示框<br>console.log（内容）:浏览器控制台打印输出信<br>prompt（提示）:浏览器弹出输入框，括号内可以写提示内容<br>注意:</p><ol><li>alert主要显示给用户，console主要显示给程序员，测试主要使用console</li><li>alert提示框会中断js程序进程</li><li>所有js代码内除了变量或者代码其他字母和文字都需要加引“”号。</li><li>加了””引号的都是字符串类型数据。</li><li>prompt输入框用户输入的内容都是字符串类型数据。</li><li>写完一行代码最好用；隔开。</li></ol><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量实质上就是在内存上申请一块用于储存数据的空间，可以把变量当成一个存放数据的盒子。<br>var  num :申明变量，申明一个名为num的变量<br>num = 10或者‘红色’，给num变量赋值为10或者红色<br>var num = 10 ； :申明变量并赋值就是变量的初始化。<br>注意:同一个变量进行多次赋值，那么最后设置值会覆盖前面的值，可以同时申明多个变量<br>例:var num = 10 ；  var  num = 20 ；这时num的值会变成20<br>       var nu = 10 ， age = 20 ；同时申明多个变量，中间用，号隔开。<br>特殊情况:<br>只申明变量不赋值                      undefined（未定义）<br>只赋值不申明                             显示该值（不建议使用）<br>不申明不赋值，直接用               报错<br>变量的命名规范:</p><ol><li>变量名由字母，数字，_，$组成，区分大小写</li><li>不能以数字开头</li><li>不能是关键字（and var 等）保留字</li><li>变量名必须有意义</li><li>遵循驼峰命名法，首字母小写，后面的单词首字母大写。</li></ol><h4 id="变量值的交换"><a href="#变量值的交换" class="headerlink" title="变量值的交换"></a>变量值的交换</h4><p>先申明一个临时变量将a变量值放到临时变量中，再将b变量的值给它，最后将临时变量存放的值给b变量<br>例:var num1 = 10 ； var num2 = 20 ；var num3； num3=num1；num1=num2；num2=num3；</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>Number:数字型</li><li>Boolean:布尔类型，true（真或等价1）false（假或等价0）</li><li>String:字符串型，字符串型都带引号 （‘ ’等价0）</li><li>Undefined:未定义</li><li>Null:空 （等价0）</li></ul><h4 id="数字进制"><a href="#数字进制" class="headerlink" title="数字进制"></a>数字进制</h4><p>在js中数字前加0代标八进制，0x代标十六进制。<br>例: </p><ul><li>var num1 = 011 ； 对应十进制9；</li><li>var num2 = 0xf ；对应十进制16；</li><li>Number.MAX_VALUE:最大值，1.796931348623157e+308</li><li>Number.MIN_VALUE:最小值，5e-32</li><li>linfinty:无穷大</li><li>-linfinty:无穷小</li><li>NaN:非数值</li><li>isNaN(值):判断这个值是否是数字类型<pre><code>          返回false则是数字类型          返回true则不是数字类型</code></pre></li></ul><h4 id="String字符串型"><a href="#String字符串型" class="headerlink" title="String字符串型"></a>String字符串型</h4><p>字符串型可以是引号中的任意文本，字符串型数据一定要用引号。<br>可以使用双引号套单引号反之亦然。<br>例: var age = ‘我是“高富帅”程序员’</p><h4 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h4><p>字符串中有些特殊的字符需要使用转义符显示。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\n</span> :换行转义符<br><span class="hljs-string">\\</span>  :斜杠<br><span class="hljs-string">\&#x27;</span>  :单引号<br><span class="hljs-string">\&quot;</span>  :双引号<br><span class="hljs-string">\t</span>  :缩进四个空格（对文字使用时会出现间距不对的问题）<br><span class="hljs-string">\b</span>  :空格<br><br></code></pre></td></tr></table></figure><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><p>.length 检查字符串长度<br>例:var age = ‘字符串，长度’<br>      alert（age.length）；显示的数值是6<br>注意:空格和标点符号都算一个字符</p><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>多个字符串之间可以使用+进行拼接<br>字符串+任何类型数据=拼接后的字符串<br>注意:+不可以写到引号内两个字符串分别需要用两个引号隔开<br>引号是匹配最近的引号进行将两者之间的数据包含。</p><h4 id="布尔型Boolean"><a href="#布尔型Boolean" class="headerlink" title="布尔型Boolean"></a>布尔型Boolean</h4><p>布尔型只有两个值 true和false，true表示真或者1，false表示假或者0<br>布尔型数据进行数字运算时true=1，false=0。</p><h4 id="Undefine和Null"><a href="#Undefine和Null" class="headerlink" title="Undefine和Null"></a>Undefine和Null</h4><p>一个变量申明后没有赋值会有默认值undefined（未定义）<br>直接用会显示 :undefined<br>与字符串相加显示 :’字符串‘undefined<br>与数字和布尔型数据相加:NaN（非数字）</p><p>申明一个变量但是不赋值，则为空（Null）<br>直接用 :显示null（空）<br>与字符串相加:‘字符串’变量名<br>与数字相加:等于原数字（Null相当于0）<br>与布尔型相加:与tru相加为1，与false相加为0.</p><h4 id="获取变量类型"><a href="#获取变量类型" class="headerlink" title="获取变量类型"></a>获取变量类型</h4><p>typeof 检测数据类型<br>例:var num = 18 ；<br>       console.log（typeof num）；结果是number。</p><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><p>​字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。<br>数字字面量:8, 9, 10<br>字符串字面量:’黑马程序员’, “大前端”<br>布尔字面量:true，false</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><p>.toString（）  例:var num = 1 ； consle.log（num.toString（））<br>String（）强制转换 例:console.log（String（num））<br>加号拼接字符串（隐性转换，建议使用） 例:console.log（num+‘’）</p><h4 id="转换为数字型"><a href="#转换为数字型" class="headerlink" title="转换为数字型"></a>转换为数字型</h4><p>parseInt（） 例:parseInt（‘234’）（只能转化整数部分，若以非数字开头则显示NaN，常用）<br>parseFloat（）例:parseFloat（‘23.33’）（可以保留小数，若以非数字开头则显示NaN，常用）<br>Number（）例:Number（‘12.33’）（强制转换，可以保留小数）<br>利用算数运算隐性转换 例:‘23’-0（保留小数）</p><h4 id="转换为布尔型"><a href="#转换为布尔型" class="headerlink" title="转换为布尔型"></a>转换为布尔型</h4><p>Boolean（）例:Boolean（其他数据类型）<br>注意:代标空，否定的值会被转化为false，例:‘ ’、0、NaN、null、undefined<br>           其他都转换为true</p><p>第二天<br>一、运算符<br>1.运算符的分类<br>算数运算，递增和递减运算，比较运算符，逻辑运算符，赋值运算符</p><p>2.算数运算符</p><ul><li>（加）、 -（减）  、<em>（乘）  、 / （除） 、 % （取余，返回除法的余数）<br>运算顺序是先</em>、/ 后加减<br>注意:+号和字符串相连会进行拼接，其他类型数据隐式转换为字符串。<pre><code>   - 、 * 、/、% 和数字型相连会将其他类型数据隐式转换为数字型。  在进行算数运算时尽量避免小数运算，因为在计算机中运算小数需要先转换成二进制再进行运算会出现误差。小数最高精度为17位，所以进行小数运算时会有误差不准确。</code></pre>例:var result = 0.1 + 0.2;    // 结果不是 0.3，而是:0.30000000000000004<br>console.log(0.07 * 100);   // 结果不是 7，  而是:7.000000000000001<br>表达式:由变量，运算符，数字等能求得值的式子。<br>返回值:由表达式运算的结果返回给开发值的数据。</li></ul><p>3.递增和递减运算符<br>前置递增和递减运算符，只能和变量一起使用不能直接跟数字或者其他数据类型。<br>注意:递增和递减运算符也可以将其他数字类型隐式转换成数字型。</p><p> ++num ，–num :相当于 num = num + 1 或者 num = num - 1<br>注意:前置运算符是先自加1或自减1，之后返回数值。</p><p>后置递增和递减运算符<br>num++  ，num–  :相当于 num = num + 1 或者 num = num - 1<br>注意:后置运算是先返回数值之后，再进行加1或者减1。<br>       若 num=10；   num = num++  ；num 为10，不是11，因为num++是先返回值再计算</p><p>4.比较运算符<br>&lt;  （小于） &lt;=  （小于等于）  &gt;    （大于）  &gt;=  （大于等于）== （判断等号）<br> != （不等号） === （全等，需要数据类型也一样） !== （不全等）<br>注意:除了===全等和！==不全等其他比较运算符都会把其他类型数据转换成数字型再进行比较。</p><p>5.逻辑运算符<br>&amp;&amp;  :逻辑与  两边都为true时结果才为，否则为false<br>例:true &amp;&amp; true （结果为true）true &amp;&amp; false （结果为false）</p><p>||   :逻辑或  两边都为false时结果才为false，否则为true<br>例:false || false（结果为false） false || true （结果为true）</p><p>！ :逻辑非，值取反，取一个布尔值的相反值，如true取反则是false。<br>注意:‘ ’、0、nul、undfined、NaN，这些特殊数据会转换成布尔类型里的false其他为true。</p><p>6.逻辑中断<br>在逻辑运算中有多个表达式时，当左边的表达式可以确定结果的时候就不会在继续运算，直接输出结果。</p><p>逻辑与的中断:当表达式1为假时则输出表达式1，之后的运算不再计算。若为真输出表达式2。如果后面只有一个表达式则直接输出最后一个表达式。<br>例:</p><script> var mun = 1 && 2 && 3 && 4 && 0 && 1 && 8 ; //num 为0 var age = 1 && 2 && 3 && 4 && 1 ; //num 为1</script><p>逻辑或的中断:当表达式1为真时则输出表达式1，之后的运算不再计算。若为假输出表达式2。如果后面只有一个表达式则直接输出最后一个表达式。<br>例:</p><script> var mun = 0 || 0 || 0 || 4 || 0 || 1 ; //num 为0 var age = 1 && 2 && 3 && 4 && 1 ; //num 为1</script><p>7.赋值运算符<br>=  :直接赋值<br>+= 、-= 、*= 、/= 、% 、:先加、减、乘、除、取余后赋值。</p><p>8.优先级<br>1级 : 小括号 （）<br>2级 :一元运算符  ++num 、–num 、！true（只有一个变量的运算）<br>3级:算术运算符  先* 、/ 后加减<br>4级:比较运算符  &lt;  &gt; &lt;=  &gt;=<br>5级:相等运算符  == 、！= 、=== 、！==<br>6级:逻辑运算符 先&amp;&amp;后||<br>7级:赋值运算符 = 、+= 、-=、*=、/=、%=</p><p>二、流程控制<br>1.流程控制分为:顺序结构、分支结构、循环结构，是用来控制代码执行的顺序的。</p><p>2.顺序结构就是按照代码的书写顺序依次执行。</p><p>3.分支结构<br>分支结构根据不同的条件执行不同的代码。（多选一）<br>if语句<br>if （判断条件）{<br>     条件成立时执行的代码；<br>}<br>if语句双分支<br>if （判断条件）{<br>    条件成立时执行的代码；<br>} else {<br>     条件不成立时执行的代码；<br>}<br>if语句多分枝<br>if （判断条件）{<br>    条件成立时执行的代码；<br>} else if （判断条件） {<br>     条件成立时执行的代码；<br>} else {<br>     条件都不成立时执行的代码；<br>}</p><p>三元表达式<br>表达式1 ？ 表达式2:表达式3；<br>表达式1成立则输出表达式2，否则输出表达式3，类似与if双支语句。<br>例:12 &gt; 10 ？20 :30；输出20.<br>注意:当进行两个字符串型的数字进行比较会出现错误的情况，最好将其中一个转换成数字型。原因是字符串进行比较时是一个字符和一个字符比较的。<br>例:‘abc’ &gt;‘abb’ ，‘5’ &gt; ‘100000’ ，结果都是true。  </p><p>switch分支流程控制<br>switch分支语句式根据不同的条件执行不同的代码，当变量的值是准确的值时可以使用switch分支语句。当变量的值不是准确的是一个范围建议使用if语句。</p><p>switch （表达式（通常是变量））{<br>           case 值/表达式 :<br>           条件成立时的代码；<br>           break；（结束）<br>           case 值/表达式 :<br>           条件成立时的代码；<br>           break；（结束）<br>           defult:<br>                     所有条件都不满足时执行的代码；<br>}<br>注意:如果执行case里的代码时没有break，则继续执行下一个case里面的代码直到有dreak为止。</p><p>第三天<br>一、循环语句<br>1.for循环语句<br>for循环语句用来多次执行某个代码。<br>for （初始化变量；条件表达式；操作表达式）{<br>      循环语句<br>}<br>初始化变量:用来记录循环次数<br>条件表达式:检查是否符合条件，符合则执行，不符合则退出循环。<br>操作表达式:用来限制循环次数避免死循环。<br>注意 :不用循环的语句一定要写在循环语句外面。</p><p>2.双重循环语句<br>for （var i = 1； i &lt;= 100；i++）{<br>       for （var j =1；j&lt;=10；j++）{<br>          循环语句<br>        }<br>}<br>双重循环语句中外循环执行一次，内循环执行全部。</p><p>3.while循环语句<br>while循环语句与for一样符合条件表达式的进入循环，不符合则退出循环。<br>var i = 1；<br>while（条件表达式） {<br>     循环体；<br>     操作表达式<br>}</p><p>4.do while 循环语句<br>do {<br>  循环语句；<br>  操作表达式；<br>}  while （条件表达式）</p><p>5.continue，break<br>continue是跳出本次循环，之后的循环继续执行。<br>break是退出整个循环。<br>例: for (var i = 1; i &lt;= 5; i++) {<br>     if (i == 3) {<br>         continue; // 跳出本次循环，跳出的是第3次循环<br>    }<br>   }<br>跳过第三次循环，继续执行之后的循环。</p><p>for (var i = 1; i &lt;= 5; i++) {<br>     if (i == 3) {<br>         break; // 直接退出整个for 循环，跳到整个for下面的语句<br>     }<br>   }<br>跳出整个循环之后的循环不再执行。    </p><p>注意:若需要for，while循环没有达到想要的结果前一直循环可以使用一下方法:<br>for（ ；；），while（’true’）将break写在想要的结果的条件后面。<br>循环使用时代码的顺序也会影响结果。</p><p>第四天<br>一、数组<br>数组就是一组数据，将相关的数据放在一起，可以存放任何形式的数据。<br>数组内的数据被称为数组元素。</p><p>数组的命名<br>命名一个新的空数组变量<br>var 数组名 = new  Array（）；<br>通过数组字面量[]使变量成为数组变量。<br>var 数组名 = []；</p><p>数组元素的访问<br>var num = [1,2,34,5,8]<br>变量名[索引号]<br>num [0]  访问num数组中的第一个数据1<br>注意:索引号是从0开始</p><p>数组元素数量<br>通过.length 来获得一个数组中数组元素的个数。<br>length属性会随着数组元素个数变化而变化。</p><p>遍历数组<br>for (var i = 0 ; i &lt; num.length ; i++){<br>num[i]<br>}</p><p>数组反转<br>var arr = [1，2，3，4，5，6，7]；<br>var newArr = [];<br>for （var i = arr.length - 1 ;i &gt;= 0; i–）{<br>    newArr[newArr.length] = arr [i]<br>}</p><p>冒泡排序<br>var arr = [1,4,2,6,12,5];<br>for (var i = 0; i &lt; arr.length - 1 ; i++) {<br>    for (var j = 0; j&lt; arr.length - 1 -i; j++ ){<br>        if(arr[j] &gt; arr[j + 1]) {<br>            var tmp = 0;<br>            tmp = arr[j];<br>            arr[j] = arr[j + 1];<br>            arr[j + 1] = tmp;<br>        }<br>    }<br>}</p><p>数组中新增元素<br>通过索引号添加新数组元素<br>var num = [1，2，3，4]；<br>num[4] = 5；<br>通过length在数组后面添加新的空数组元素<br>num.length = 6；<br>注意:这种方法创建的新元素是空的。</p><p>二、函数</p><p>函数是封装了一段可以被重复调用的代码块。</p><p>函数的命名</p><ol><li>自定义函数<br>function 函数名 () {<br>//函数代码<br>}</li></ol><p>2.匿名函数（函数表达式）<br>var num = function () {<br>    //函数代码<br>}</p><p>函数的调用<br>函数名（）<br>注意:调用函数必须带上小括号。<br>          当函数里面套一个函数时，只能在外层函数内调用，在外层函数外不能调用。<br>         function num1() {</p><pre><code>        function num2(a, b) &#123;            return a * 0 + b * 0        &#125;        function num3() &#123;            function num4() &#123;                console.log(num2(1, 2));            &#125;            num4()        &#125;        num3()    &#125;    num1()</code></pre><p>函数的封装<br>function getSum () {<br>    var sumNum = 0;<br>    for (var i = 1; i &lt;=100; i++){<br>        sumNum += i;<br>    }<br>    return sumNum<br>}</p><p>函数的参数<br>函数有两个参数分别为形参和实参，函数可以有参数也可以没有。<br>function num (形参1，形参2…){<br>    console.log(形参1)<br>    console.log(形参2)<br>    …<br>}<br>num(实参1，实参2…)</p><p>实参和形参是一一对应的关系没有数量的限制，可以是数字，字符串或者其它类型数据，参数与参数之间用，隔开。</p><p>注意:当实参个数多于形参个数，则按顺序一一对应多余的实参不管。<br>          当实参个数小于形参个数，多的形参定义为undefined。</p><p>函数的返回值<br>函数执行后可以通过return返回指定数据。<br>return不仅可以返回数值还可以结束整个函数，在return后面的代码不会执行。<br>如果函数没有return返回数据，打印函数会先执行函数之后显示undefined。</p><p>continue:跳过当前循环<br>break:结束整个循环<br>return:结束循环并结束函数返回return值</p><p>arguments的使用<br>arguments实际上是函数的内置对象属于伪数组，可以接受所有传送的实参。<br>伪数组具有length属性和索引号访问，也可以通过for循环进行遍历。<br>但是不能使用数组里的push（在数组的最后开始添加元素），pop（在数组的最前面开始添加元素）等方法</p><p>第五天</p><p>一、作用域<br>作用域就是一段代码的名字在一定范围内有效，使代码更加的可靠减少命名冲突。（es6前的版本）<br>作用域分为:全局作用域和局部作用域。</p><p>全局作用域<br>在整个js文件或者script标签中都是有效的。</p><p>局部作用域<br>只在函数内有效的，又称为函数作用域。</p><p>块级作用域<br>es6之前的js是没有块级作用域的这时es6新增的。<br>在java和其它语言中有块及作用域。</p><p>块级作用域是用大括号{}包括的范围。<br>在块级作用域内申明的变量不能在{}大括号外访问。</p><p>变量的作用域<br>变量的作用域分为:全局变量，局部变量</p><p>全局变量<br>全局变量是指在全局作用域下申明的变量，可以在任何位置访问。<br>注意:若变量没有申明直接赋值也是全局变量，不建议使用。<br>           function num (){<br>               var a = b = c = 8;<br>           }</p><p>上述情况中变量b，c属于未申明直接赋值属于全局变量，a属于局部变量。赋值时从右往左进行赋值的。</p><p>局部变量<br>在局部作用域申明的变量或函数内申明的变量，只能在当前作用域下访问其他位置无法访问。<br>注意:函数中的形参也是属于局部变量。</p><p>作用域链<br>当一个函数内还有函数，根据内部函数可以访问外部函数变量的机制，用链式查找决定哪写数据能被内部函数调用，这就称之为作用域链。<br>作用域链总结就是，就近原则。通过就近原则来查找最终值。变量的赋值也是根据就近原则给最近的相同变量进行赋值。</p><p>二、预解析</p><p>浏览器执行流程<br>1.先进行语法校验，当语法校验不通过时则整个js都不会执行<br>2.语法校验通过后，进行预解析，将var（变量声明）function（函数申明）提升到当前作用域的最前面<br>注意:var提升的只是变量的声明，变量赋值并不会提升，而function提升是将整个函数提升到当前作用域最前面。但是在代码执行过程中我们不看函数申明只看函数调用，因为函数只有调用后才会执行。<br>3.按照从上到下的顺序依次执行。</p><p>三、对象</p><p>定义<br>万物皆对象，对象指某一个具体的事物。<br>在javascript中对象是一组无序的属性和方法的集合。<br>属性是这个事物的特征，比如一个人的身高，体重，性别等（常用名词）<br>方法是这个事物能做什么，比如一个可以打篮球，唱歌，写代码等（常用动词）</p><p>创建对象与调用<br>1.使用对象的字面量{}创建对象。<br>var obj = {<br>    nam : ‘小明’,<br>    sex : ‘男’,<br>    run : function (){<br>        console.log(‘跑步)<br>    },<br>    son : function (){<br>        console.log(‘微光’)<br>    }<br>}</p><p>注意:对象里的属性和方法使用键值对的方式书写方式   属性名（方法名）:属性值（方法）每个属性和方法后面用逗号’，’隔开。<br>属性名后面跟的是一个值，方法名后面跟的是函数。</p><p>2.函数的调用<br>属性值的调用<br>对象名.属性名   对象名[‘属性名’]（一定要加引号，中括号中可以是变量但是变量的值必须是属性名的字符串）<br>obj.nam;<br>obj[‘nam’];<br>var unam = ‘nam’;<br>obj[unam]</p><p>方法的调用<br>对象名.方法名（） 注意:中括号写法不能用来调用方法。<br>obj.run();</p><p>3.修改和新增对象属性或方法<br>属性值的修改:先调用属性然后进行重新赋值<br>注意:属性和方法永远不会重复，只会有一个，后面的数据会覆盖前面的数据。<br>obj.nam = ‘小红’;<br>obj[‘nam’] = ‘小红’;</p><p>新增属性:对象名.新的属性名 = 新的属性值<br>                 对象名[‘新的属性名’] = 新的属性值<br>obj.age = 18;<br>obj[‘age’]=18;</p><p>注意:新增属性其实做了两步操做，先新建一个属性然后进行赋值<br>方法的修改:先调用方法然后重新赋值<br>obj.run() = function () {<br>    console.log(‘拼命的跑’)<br>}</p><p>方法的新增:对象名.新增的方法名 = 新增的方法函数<br>obj.song() = function(){<br>    console.log(‘冰雨’)<br>}</p><p>4.构造函数创建对象<br>function Obj (nam,sex){<br>    this.nam = nam ;<br>    this.sex = sex ;<br>    this.run = function (txt){<br>        console.log(txt)<br>    }<br>}<br>var xiaoming = new Obj(‘小明’,’男’);//传入属性<br>xiaoming.run(‘跑步’)//传入方法</p><p>注意:构造函数名首字母大写，构造函数中如果使用的是this不需要写return返回值，会自动返回创建的对象<br>调用构造函数必须要写 new 才能创建新的对象<br>调用构造函数创建新的对象和使用函数一样，函数小括号里写形参，引用时小括号里写实参。<br>但是方法需要单独调用传入数据。<br>需要用一个变量接受这个对象。<br>构造函数创建的对象可以修改和新增属性但是不能修改和新增方法。</p><p>new关键字的作用（重点）<br>1.构造函数在开始执行之前，new关键字先在内存中申请一个空间在空间内存放创建的一个空对象<br>2.把所有this全部指向创建的空对象<br>3.通过this添加属性和方法传入新建对象中<br>4.将新建的对象返回给调用者</p><p>遍历对象<br>使用for…in …. 遍历对象<br>for (变量名 in 对象名) {<br>    console.log(变量名)//属性名<br>    console.log（对象名[变量名]）//属性值<br>}</p><p>注意:变量名通常为 var key 或者 var k 都可以，变量名实际上相当于对象里面的属性名<br>这里调用数值的只能使用中括号的方法，这种方法只能打印方法里的函数不会调用函数。</p><p>第六天<br>JavaScript中对象分为三种，自定义对象，内置对象，浏览器对象。<br>内置对象是js中本身就有的对象里面有一些常用的或者最基本且必要的功能。</p><p>由于内置对象很多所以需要学会查询文档来帮助我们了解这些内置对象<br>推荐MDN:   <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a> 查询。</p><p>一、Math对象（数学对象）<br>Math对象不是构造函数，它具有数学常数，和函数的属性和用法。跟数学相关的运算可以使用Math里的成员<br>1.Math.PI             圆周率（是一个固定的数值）<br>2.Math.fioor()       向下取整（括号内写入需要取整的数字，又称地板函数）<br>3.Math.ceil()         向上取整（同上，又称天花板函数）<br>4.Math.round()     四舍五入（同上，取最近的整数，注意:-3.5结果是-3，-3.54结果是-4 因为距离-4最近）<br>5.Math.abs()        取绝对值<br>6.Math.max()       求最大值（括号里的数字以逗号隔开，注意不可以使用数组只能输入数字）<br>7.Math.min()        求最小值（同上）<br>8.Math.random()  取[0，1)之间的随机浮点数（注意括号里不需要传参数）</p><p>指定范围内的随机数<br>Math.random();//[0，1)之间的随机浮点数<br>Math.random() * 15 ;//[0，15)之间的随机浮点数<br>parseInt(Math.random() * 15 );//[0，14]之间的随机整数<br>parseInt(Math.random() * (15 + 1));//[0，15]之间的随机整数<br>parseInt(5 + Math.random() * (15 - 5 + 1));//[5，15]之间的随机整数<br>function stochastic (a,b) {<br>    return parseInt(a + Math.random() * (b - a + 1));<br>}<br>//[a，b]的随机整数</p><p>注意这里的a是小于b的</p><p>二、日期对象<br>日期对象Date是一个构造函数，所以使用之前需要先调用Date创建新的对象才能使用。<br>1.获取当前时间对应的日期对象<br>var now = new Date();</p><p>2.获取指定日期对象<br>var now = new Date(‘2020-12-23’)<br>var now = new Date(‘2020/1/21’)<br>var now = new Date(‘2020-4-13 12:32:12’)</p><p>3.创建时间对象后可以获取该时间的年月日<br>now.getFullYear();//年<br>now.getMonth();//月，因为国外是从0开始计数所以得到的月数会少1需要+1<br>now.getDate();//日<br>now.getDay();//国外一周也是从0开始，0代标周日。</p><p>4.获取时间戳<br>now.valueOF();//获取目标原始值<br>now.getTime();//获取目标原始值（推荐使用）<br>+now;//一元加号，可以将其他数据类型转换成数字型（推荐使用）<br>+new Date();//同上，只是两种不同的写法（推荐使用）<br>Date.now();//HTML5中提供的方法，有兼容性问题</p><p>5.倒计时<br>var now = new Date();<br>funcion countDown(terminus) {<br>    var t1 = +now;//获取当前时间戳<br>    var t2 = +new Date(terminus);//获取目标时间的时间戳<br>    var time = parseInt((t2 - t1) / 1000);//计算时间差并换算成秒取整<br>    var h = time / 60 / 60 ;//将总共的秒数换算成小时数<br>    h = h &lt; 10 ? ‘0’ + h : h ;//倒计时通常是两位数显示所以小于10时需要补0<br>    var m = time / 60 % 60 ;//总秒数换算成分钟，进行取余得到不足一小时的部分<br>    m = m &lt; 10 ? ‘0’ + m : m ;//补0<br>   var s = time % 60 ;//取余得到不足一分钟的部分，因为不需要显示总共的秒数<br>   s = s &lt; 10 ? ‘0’ + s : s ;//补0<br>   return h + ‘:’ + m + ‘:’ + s;//输出结果<br>}</p><p>注释:count down :倒计时<br>          terminus :终点</p><p>三、数组对象<br>1.创建数组<br>创建数组有两种方法<br>字面量创建<br>var num = [1,2,4];</p><p>内置数组构造函数创建<br>var num = new Array()</p><p>使用构造函数创建新的数组不想要空数组可以在创造的时候传入参数即可。<br>注意:当传入多个参数时，传入的参数就是数组元素<br>          当传入一个参数时，则是规定了数组的长度</p><p>2.检查是否是数组<br>instanceof  运算符<br>使用方法:变量  instanceof  数据类型  ，变量数据类型和后面的数据类型相同返回true，否则返回false<br>num instanceof Array ;//检测是否是数组类型<br>num instanceof Function ;//检测是否是函数类型</p><p>Array.isArray() 判断<br>使用方法:将需要判断的变量名放入小括号内，是数组类型则返回true，否则返回false。<br>Array.isArray(num);//检测是否为数组类型</p><p>3.添加或删除数组元素方法<br>添加元素<br>push（参数1，参数2..） :末尾添加元素，可以是多个，修改原数组，返回新数组长度<br>var num = [1,2,3,4];<br>num.push(2,3,4)</p><p>unshift（参数1，参数2..） :在前面添加元素，可以是多个，修改原数组，返回新数组长度<br>var num = [1,2,3,4];<br>num.unshift(2,3,4);</p><p>删除元素<br>pop（）删除末尾的一个元素，修改原数组，返回被删除的元素<br>var num = [1,2,3,4];<br>num.pop();</p><p>shift（）删除末尾的一个元素，修改原数组，返回被删除的元素<br>var num = [1,2,3,4];<br>num.shift();</p><p>splice(起始位置，个数) 从起始位置开始，删除输入的个数，返回删除的元素组成的新数组，改变原数组<br>var num = [1,2,3,4];<br>num.splice(1,2);</p><p>数组的排序、翻转、查询<br>数组的排序<br>sort（）小括号内是一个函数，修改原数组，返回排序的数组<br>var num = [5,2,8,4];<br>num.sort(function (a,b){<br>    return a - b;//若 a - b 大于0则互换位置，否则不换，该成b - a 则是从大到小排序<br>})</p><p>数组的翻转<br>reverse（）小括号内不需要写参数。翻转数组，修改原数组，返回翻转后的数组<br>var num = [5,2,8,4];<br>num.reverse();</p><p>数组的查询<br>indexOf（）括号内写要查询的元素，从前查询该元素第一次出现的位置，返回索引号。<br>可以跟第二个参数，表示从该索引号开始查找<br>var num = [1,1,2,5,4,7,4,2,5];<br>num.indexOf(5);//结果为3<br>num.indexOf(5,4);//结果为8</p><p>lastIdexOf（）括号内写要查询的元素，从后查询该元素第一次出现的位置，返回索引号。<br>可以跟第二个参数，表示从该索引号开始查找<br>var num = [1,1,2,5,4,7,4,2,5];<br>num.lastIndexOf(5);//结果为8<br>num.lastIndexOf(5,7);//结果为3</p><p>注意:若该数组中没有该元素则返回-1。</p><p>数组去重<br>var num = [1,1,2,5,4,7,4,2,5];<br>var newNum = [];<br>for (var i = 0 ; i &lt; num.length; i++){//遍历数组num<br>    if (newNum.indexOf(num[i]) == -1 ){//判断新数组newNum有没有这个元素<br>        newNum.push(num[i]);//将没有的元素放入新数组中<br>    }<br>}</p><p>数组转换成字符串<br>var num = [‘a’,’b’.’c’,’d’]<br>num.join(‘+’)//括号内是转换成字符串时每个元素中间的间隔符，如果不需要就写一个空的字符串（推荐使用）<br>//结果是:a+b+c+d<br>num.toString()//括号内不需要写参数，转换成字符串默认用逗号隔开。<br>//结果是:a,b,c,d</p><p>注意:join如果不传参数默认以逗号隔开。两种方法返回的是字符串，不改变原数组。</p><p>数组的拼接<br>var num = [‘a’,’b’.’c’,’d’];<br>var num1 = [5,6,7,8];<br>var num2 = [1,2,3,4];<br>num.concat(num1,num2);</p><p>注意:返回的是拼接后的新数组，不影响原数组。</p><p>数组的截取<br>var num = [‘a’,’b’.’c’,’d’];<br>num.slice(起始位置,结束位置)//截取从起始位置开始到结束位置</p><p>注意:截取的元素包含起始位置但不包含结束位置，返回的是截取后的新数组，不改变原数组。</p><p>第七天<br>一、基本包装类型<br>之前使用length可以查询字符串的长度，但是length属性是只有对象才有的属性。之所以可以使用<br>是因为js会把简单数据类型包装成复杂数据类型就是对象。<br>基本包装就是把基本类型数据包装成复杂数据类型，这样基本数据类型就有了属性和方法。<br>使用String(),Number(),Boolean()。可以把相对应的基础数据类型包装成复杂数据类型。<br>js在包装基础数据类型时做了一下步骤:<br>var str =’afasfasfasdf’;<br>str.length;//当查询字符串长度时<br>var tamp = str.String();//将基础变量转换成复杂数据类型并赋值给临时变量<br>tamp.length;//将临时变量的length长度值返回给调用者<br>tamp = null;//将临时变量赋值为空，之后由内存清理机制进行销毁</p><p>二、字符串相关</p><p>字符串的不可变性<br>在js中字符串变量的值，就是字符串是不会改变的。虽然重新对变量赋值看上去对应的字符串变了，但实际上只是将地址改变了之前的字符串依然保存在内存里。当大量操作字符串会导致资源浪费。<br>所以在实际操作中应当尽量避免过多的操作字符串造成资源浪费。</p><p>根据字符返回具体位置<br>字符串根据基本包装类型可以调用部分方法操作字符串。<br>var str = ‘asdfasjdflkjasdf’;<br>str.indexOf(‘d’);//从前开始查找，返回查找到第一d出现的索引号，没找到返回-1<br>//可以跟第二个参数，第二个参数是从什么位置开始查找。<br>//同理lastIndexOf也可以使用。</p><p>案例:查找字符串中某个字符出现次数:<br>var str = ‘asdfasjdflkjasdf’;<br>var n = 0;//申明一个变量接收查询字符的索引号<br>var num = [];//申明一个变量储存每次查询的索引号<br>while(true){//设置死循环，因为不知道要循环几次<br>    n = str.indexOf(‘d’,n);//保存查询到的索引号<br>    if (n == -1) {//判断结束循环条件<br>        break;<br>    } else {//将查询到的索引号保存。<br>        num.push(n)<br>    }<br>    n++//更改起始位置<br>}</p><p>根据位置返回字符串<br>1.索引号方式获取<br>var str = ‘qwertyui’;<br>str[3]//结果为’r’</p><p>2.使用.charAt()方式获取<br>var str = ‘sdkfjhas’;<br>str.charAt(4);//结果为‘j’</p><p>3.使用.charCodeAt()方法获取的是该字符所对应ASCII码，ASCII码是用来判断用户按的是哪个按键。</p><p>案例:判断出现最多的字符和次数<br>var str = ‘ asdfsdfasdfd’;<br>var arr ={};//创建对象用来储存变量中的字符和出现的次数<br>for (var i = 0 ; i &lt; str.length; i++) {<br>    var strt = str[i];//<br>    if (arr[strt]) {//判断arr对象中是否有这个字符对应的属性，有则加一<br>        arr[strt]++<br>    } else {//没有则创建这个字符属性并赋值<br>        arr[strt] = 1;<br>    }<br>}<br>var max = 0 ;//设置变量储存最大值<br>var maxId = ‘’;//设置变量储存最大值对应的字符<br>for (var kay in arr) {//遍历对象<br>    if (arr[kay] &gt; max){//判断最大值，若大于则对max，和maxI重新赋值<br>        max = arr[kay];<br>        maxId = kay;<br>    }<br>}<br>console.log(max,maxId)</p><p>字符串操作方法<br>字符串.concat(字符串1，字符串2)  :用来拼接多个字符串相当于+，但是+更常用<br>var str = ‘fasdf’;<br>var str1 = ‘sadf’;<br>var str2 = ‘gdfgf’;<br>str.concat(str1,str2)//返回的是拼接后新的字符串</p><p>字符串的截取<br>.slice(起始位置，终止位置)，与数组的截取一样从起始位置开始（包含）到终止位置（不包含）的字符，可以是负值。为负值时是从后往前<br>var str = ‘fasdf’;<br>str.slice(0,3)</p><p>注意:一下方法数组无法使用</p><p>.substr(起始位置，截取个数)，从起始位置开始截取设置个数的字符<br>var str = ‘fasdf’;<br>str.substr(0,3)</p><p>.substring(起始位置，终止位置)，与数组的截取一样从起始位置开始（包含）到终止位置（不包含）的字符，不可以是负值<br>var str = ‘fasdf’;<br>str.substring(0,3)</p><p>字符串的替换<br>.replace(被替换的字符，要替换的字符) ，替换的是第一个符合条件的字符。<br>var str = ‘fasdf’;<br>str.replace(‘a’,’sadf’)</p><p>字符串转换成数组<br>split(‘分割字符’) :将字符串根据分割字符分割为数组，若字符串没有分割符则写空字符‘’即可<br>var str = ‘fasdf’;//没有分割符<br>str.split(‘’)<br>var str1 = ‘a1c1f1g1h1d’//有分割符<br>str1.split(‘1’)</p><p>三、简单数据类型和复杂数据类型       </p><p>1.简单数据类型<br>简单数据类型在储存时变量中储存的是值本身</p><p>2.复杂数据类型<br>复杂数据类型在储存时变量中储存的其实是一个十六进制的地址值</p><p>3.堆和栈<br>栈 :由操作系统自动分配和释放，用于存储简单数据类型的变量值、局部变量值、变量名和复杂数据类型的地址<br>存储方式:</p><p>堆:由程序员分配和释放，如果程序员没有释放则由垃圾回收机制回收，用于存放复杂数据类型本身。<br>存储方式:</p><p>4.传参方式<br>简单数据类型变量传递的实际上是值本身<br>复杂数据类型变量传递的是十六进制的地址值</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/01/28/hello-world/"/>
    <url>/2021/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
